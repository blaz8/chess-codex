/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fworkspaces%2Fchess-codex%2Fsrc%2Fcomponents%2FChessGame.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fworkspaces%2Fchess-codex%2Fsrc%2Fcomponents%2FChessGame.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/ChessGame.tsx */ \"(app-pages-browser)/./src/components/ChessGame.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMzNfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRndvcmtzcGFjZXMlMkZjaGVzcy1jb2RleCUyRnNyYyUyRmNvbXBvbmVudHMlMkZDaGVzc0dhbWUudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyZGVmYXVsdCUyMiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLHNMQUFzSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2NlNTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJkZWZhdWx0XCJdICovIFwiL3dvcmtzcGFjZXMvY2hlc3MtY29kZXgvc3JjL2NvbXBvbmVudHMvQ2hlc3NHYW1lLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fworkspaces%2Fchess-codex%2Fsrc%2Fcomponents%2FChessGame.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/chess.js@1.4.0/node_modules/chess.js/dist/esm/chess.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/chess.js@1.4.0/node_modules/chess.js/dist/esm/chess.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BISHOP: function() { return /* binding */ BISHOP; },\n/* harmony export */   BLACK: function() { return /* binding */ BLACK; },\n/* harmony export */   Chess: function() { return /* binding */ Chess; },\n/* harmony export */   DEFAULT_POSITION: function() { return /* binding */ DEFAULT_POSITION; },\n/* harmony export */   KING: function() { return /* binding */ KING; },\n/* harmony export */   KNIGHT: function() { return /* binding */ KNIGHT; },\n/* harmony export */   Move: function() { return /* binding */ Move; },\n/* harmony export */   PAWN: function() { return /* binding */ PAWN; },\n/* harmony export */   QUEEN: function() { return /* binding */ QUEEN; },\n/* harmony export */   ROOK: function() { return /* binding */ ROOK; },\n/* harmony export */   SEVEN_TAG_ROSTER: function() { return /* binding */ SEVEN_TAG_ROSTER; },\n/* harmony export */   SQUARES: function() { return /* binding */ SQUARES; },\n/* harmony export */   WHITE: function() { return /* binding */ WHITE; },\n/* harmony export */   validateFen: function() { return /* binding */ validateFen; },\n/* harmony export */   xoroshiro128: function() { return /* binding */ xoroshiro128; }\n/* harmony export */ });\n// @generated by Peggy 4.2.0.\n//\n// https://peggyjs.org/\n\n\n\n  function rootNode(comment) {\n  \treturn comment !== null ? { comment, variations: [] } : { variations: []}\n  }\n\n  function node(move, suffix, nag, comment, variations) {\n  \tconst node = { move, variations };\n\n    if (suffix) {\n    \tnode.suffix = suffix;\n    }\n\n    if (nag) {\n    \tnode.nag = nag;\n    }\n\n    if (comment !== null) {\n    \tnode.comment = comment;\n    }\n\n    return node\n  }\n\n  function lineToTree(...nodes) {\n  \tconst [root, ...rest] = nodes;\n\n    let parent = root;\n\n    for (const child of rest) {\n    \tif (child !== null) {\n        \tparent.variations = [child, ...child.variations];\n            child.variations = [];\n            parent = child;\n        }\n    }\n\n  \treturn root\n  }\n\n  function pgn(headers, game) {\n  \tif (game.marker && game.marker.comment) {\n    \tlet node = game.root;\n        while (true) {\n        \tconst next = node.variations[0];\n            if (!next) {\n            \tnode.comment = game.marker.comment;\n            \tbreak\n            }\n            node = next;\n        }\n    }\n\n  \treturn {\n    \theaders,\n        root: game.root,\n        result: (game.marker && game.marker.result) ?? undefined\n    }\n  }\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n      ? this.location.source.offset(s)\n      : s;\n    var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", offset_s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + offset_s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { pgn: peg$parsepgn };\n  var peg$startRuleFunction = peg$parsepgn;\n\n  var peg$c0 = \"[\";\n  var peg$c1 = \"\\\"\";\n  var peg$c2 = \"]\";\n  var peg$c3 = \".\";\n  var peg$c4 = \"O-O-O\";\n  var peg$c5 = \"O-O\";\n  var peg$c6 = \"0-0-0\";\n  var peg$c7 = \"0-0\";\n  var peg$c8 = \"$\";\n  var peg$c9 = \"{\";\n  var peg$c10 = \"}\";\n  var peg$c11 = \";\";\n  var peg$c12 = \"(\";\n  var peg$c13 = \")\";\n  var peg$c14 = \"1-0\";\n  var peg$c15 = \"0-1\";\n  var peg$c16 = \"1/2-1/2\";\n  var peg$c17 = \"*\";\n\n  var peg$r0 = /^[a-zA-Z]/;\n  var peg$r1 = /^[^\"]/;\n  var peg$r2 = /^[0-9]/;\n  var peg$r3 = /^[.]/;\n  var peg$r4 = /^[a-zA-Z1-8\\-=]/;\n  var peg$r5 = /^[+#]/;\n  var peg$r6 = /^[!?]/;\n  var peg$r7 = /^[^}]/;\n  var peg$r8 = /^[^\\r\\n]/;\n  var peg$r9 = /^[ \\t\\r\\n]/;\n\n  var peg$e0 = peg$otherExpectation(\"tag pair\");\n  var peg$e1 = peg$literalExpectation(\"[\", false);\n  var peg$e2 = peg$literalExpectation(\"\\\"\", false);\n  var peg$e3 = peg$literalExpectation(\"]\", false);\n  var peg$e4 = peg$otherExpectation(\"tag name\");\n  var peg$e5 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false);\n  var peg$e6 = peg$otherExpectation(\"tag value\");\n  var peg$e7 = peg$classExpectation([\"\\\"\"], true, false);\n  var peg$e8 = peg$otherExpectation(\"move number\");\n  var peg$e9 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e10 = peg$literalExpectation(\".\", false);\n  var peg$e11 = peg$classExpectation([\".\"], false, false);\n  var peg$e12 = peg$otherExpectation(\"standard algebraic notation\");\n  var peg$e13 = peg$literalExpectation(\"O-O-O\", false);\n  var peg$e14 = peg$literalExpectation(\"O-O\", false);\n  var peg$e15 = peg$literalExpectation(\"0-0-0\", false);\n  var peg$e16 = peg$literalExpectation(\"0-0\", false);\n  var peg$e17 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"1\", \"8\"], \"-\", \"=\"], false, false);\n  var peg$e18 = peg$classExpectation([\"+\", \"#\"], false, false);\n  var peg$e19 = peg$otherExpectation(\"suffix annotation\");\n  var peg$e20 = peg$classExpectation([\"!\", \"?\"], false, false);\n  var peg$e21 = peg$otherExpectation(\"NAG\");\n  var peg$e22 = peg$literalExpectation(\"$\", false);\n  var peg$e23 = peg$otherExpectation(\"brace comment\");\n  var peg$e24 = peg$literalExpectation(\"{\", false);\n  var peg$e25 = peg$classExpectation([\"}\"], true, false);\n  var peg$e26 = peg$literalExpectation(\"}\", false);\n  var peg$e27 = peg$otherExpectation(\"rest of line comment\");\n  var peg$e28 = peg$literalExpectation(\";\", false);\n  var peg$e29 = peg$classExpectation([\"\\r\", \"\\n\"], true, false);\n  var peg$e30 = peg$otherExpectation(\"variation\");\n  var peg$e31 = peg$literalExpectation(\"(\", false);\n  var peg$e32 = peg$literalExpectation(\")\", false);\n  var peg$e33 = peg$otherExpectation(\"game termination marker\");\n  var peg$e34 = peg$literalExpectation(\"1-0\", false);\n  var peg$e35 = peg$literalExpectation(\"0-1\", false);\n  var peg$e36 = peg$literalExpectation(\"1/2-1/2\", false);\n  var peg$e37 = peg$literalExpectation(\"*\", false);\n  var peg$e38 = peg$otherExpectation(\"whitespace\");\n  var peg$e39 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\"], false, false);\n\n  var peg$f0 = function(headers, game) { return pgn(headers, game) };\n  var peg$f1 = function(tagPairs) { return Object.fromEntries(tagPairs) };\n  var peg$f2 = function(tagName, tagValue) { return [tagName, tagValue] };\n  var peg$f3 = function(root, marker) { return { root, marker} };\n  var peg$f4 = function(comment, moves) { return lineToTree(rootNode(comment), ...moves.flat()) };\n  var peg$f5 = function(san, suffix, nag, comment, variations) { return node(san, suffix, nag, comment, variations) };\n  var peg$f6 = function(nag) { return nag };\n  var peg$f7 = function(comment) { return comment.replace(/[\\r\\n]+/g, \" \") };\n  var peg$f8 = function(comment) { return comment.trim() };\n  var peg$f9 = function(line) { return line };\n  var peg$f10 = function(result, comment) { return { result, comment } };\n  var peg$currPos = options.peg$currPos | 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = peg$currPos;\n  var peg$maxFailExpected = options.peg$maxFailExpected || [];\n  var peg$silentFails = options.peg$silentFails | 0;\n\n  var peg$result;\n\n  if (options.startRule) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      if (pos >= peg$posDetailsCache.length) {\n        p = peg$posDetailsCache.length - 1;\n      } else {\n        p = pos;\n        while (!peg$posDetailsCache[--p]) {}\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos, offset) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    var res = {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n    return res;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsepgn() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsetagPairSection();\n    s2 = peg$parsemoveTextSection();\n    s0 = peg$f0(s1, s2);\n\n    return s0;\n  }\n\n  function peg$parsetagPairSection() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsetagPair();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsetagPair();\n    }\n    s2 = peg$parse_();\n    s0 = peg$f1(s1);\n\n    return s0;\n  }\n\n  function peg$parsetagPair() {\n    var s0, s2, s4, s6, s7, s8, s10;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    peg$parse_();\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s2 = peg$c0;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n    if (s2 !== peg$FAILED) {\n      peg$parse_();\n      s4 = peg$parsetagName();\n      if (s4 !== peg$FAILED) {\n        peg$parse_();\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s6 = peg$c1;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e2); }\n        }\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parsetagValue();\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s8 = peg$c1;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s8 !== peg$FAILED) {\n            peg$parse_();\n            if (input.charCodeAt(peg$currPos) === 93) {\n              s10 = peg$c2;\n              peg$currPos++;\n            } else {\n              s10 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e3); }\n            }\n            if (s10 !== peg$FAILED) {\n              s0 = peg$f2(s4, s7);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsetagName() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r0.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = input.charAt(peg$currPos);\n        if (peg$r0.test(s2)) {\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e5); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsetagValue() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r1.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = input.charAt(peg$currPos);\n      if (peg$r1.test(s2)) {\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e7); }\n      }\n    }\n    s0 = input.substring(s0, peg$currPos);\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e6); }\n\n    return s0;\n  }\n\n  function peg$parsemoveTextSection() {\n    var s0, s1, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseline();\n    peg$parse_();\n    s3 = peg$parsegameTerminationMarker();\n    if (s3 === peg$FAILED) {\n      s3 = null;\n    }\n    peg$parse_();\n    s0 = peg$f3(s1, s3);\n\n    return s0;\n  }\n\n  function peg$parseline() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecomment();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = [];\n    s3 = peg$parsemove();\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      s3 = peg$parsemove();\n    }\n    s0 = peg$f4(s1, s2);\n\n    return s0;\n  }\n\n  function peg$parsemove() {\n    var s0, s4, s5, s6, s7, s8, s9, s10;\n\n    s0 = peg$currPos;\n    peg$parse_();\n    peg$parsemoveNumber();\n    peg$parse_();\n    s4 = peg$parsesan();\n    if (s4 !== peg$FAILED) {\n      s5 = peg$parsesuffixAnnotation();\n      if (s5 === peg$FAILED) {\n        s5 = null;\n      }\n      s6 = [];\n      s7 = peg$parsenag();\n      while (s7 !== peg$FAILED) {\n        s6.push(s7);\n        s7 = peg$parsenag();\n      }\n      s7 = peg$parse_();\n      s8 = peg$parsecomment();\n      if (s8 === peg$FAILED) {\n        s8 = null;\n      }\n      s9 = [];\n      s10 = peg$parsevariation();\n      while (s10 !== peg$FAILED) {\n        s9.push(s10);\n        s10 = peg$parsevariation();\n      }\n      s0 = peg$f5(s4, s5, s6, s8, s9);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveNumber() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r2.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = input.charAt(peg$currPos);\n      if (peg$r2.test(s2)) {\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\n      }\n    }\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c3;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e10); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse_();\n      s4 = [];\n      s5 = input.charAt(peg$currPos);\n      if (peg$r3.test(s5)) {\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e11); }\n      }\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = input.charAt(peg$currPos);\n        if (peg$r3.test(s5)) {\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e11); }\n        }\n      }\n      s1 = [s1, s2, s3, s4];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesan() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c4) {\n      s2 = peg$c4;\n      peg$currPos += 5;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n    }\n    if (s2 === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c5) {\n        s2 = peg$c5;\n        peg$currPos += 3;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e14); }\n      }\n      if (s2 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c6) {\n          s2 = peg$c6;\n          peg$currPos += 5;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e15); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c7) {\n            s2 = peg$c7;\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e16); }\n          }\n          if (s2 === peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = input.charAt(peg$currPos);\n            if (peg$r0.test(s3)) {\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e5); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = [];\n              s5 = input.charAt(peg$currPos);\n              if (peg$r4.test(s5)) {\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e17); }\n              }\n              if (s5 !== peg$FAILED) {\n                while (s5 !== peg$FAILED) {\n                  s4.push(s5);\n                  s5 = input.charAt(peg$currPos);\n                  if (peg$r4.test(s5)) {\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e17); }\n                  }\n                }\n              } else {\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          }\n        }\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = input.charAt(peg$currPos);\n      if (peg$r5.test(s3)) {\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e18); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesuffixAnnotation() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r6.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e20); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      if (s1.length >= 2) {\n        s2 = peg$FAILED;\n      } else {\n        s2 = input.charAt(peg$currPos);\n        if (peg$r6.test(s2)) {\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e20); }\n        }\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e19); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenag() {\n    var s0, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    peg$parse_();\n    if (input.charCodeAt(peg$currPos) === 36) {\n      s2 = peg$c8;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e22); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = input.charAt(peg$currPos);\n      if (peg$r2.test(s5)) {\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\n      }\n      if (s5 !== peg$FAILED) {\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = input.charAt(peg$currPos);\n          if (peg$r2.test(s5)) {\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e9); }\n          }\n        }\n      } else {\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s3 = input.substring(s3, peg$currPos);\n      } else {\n        s3 = s4;\n      }\n      if (s3 !== peg$FAILED) {\n        s0 = peg$f6(s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      if (peg$silentFails === 0) { peg$fail(peg$e21); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment() {\n    var s0;\n\n    s0 = peg$parsebraceComment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parserestOfLineComment();\n    }\n\n    return s0;\n  }\n\n  function peg$parsebraceComment() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c9;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e24); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = input.charAt(peg$currPos);\n      if (peg$r7.test(s4)) {\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e25); }\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = input.charAt(peg$currPos);\n        if (peg$r7.test(s4)) {\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e25); }\n        }\n      }\n      s2 = input.substring(s2, peg$currPos);\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s3 = peg$c10;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e26); }\n      }\n      if (s3 !== peg$FAILED) {\n        s0 = peg$f7(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e23); }\n    }\n\n    return s0;\n  }\n\n  function peg$parserestOfLineComment() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 59) {\n      s1 = peg$c11;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e28); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = input.charAt(peg$currPos);\n      if (peg$r8.test(s4)) {\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e29); }\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = input.charAt(peg$currPos);\n        if (peg$r8.test(s4)) {\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e29); }\n        }\n      }\n      s2 = input.substring(s2, peg$currPos);\n      s0 = peg$f8(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e27); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsevariation() {\n    var s0, s2, s3, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    peg$parse_();\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s2 = peg$c12;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e31); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseline();\n      if (s3 !== peg$FAILED) {\n        peg$parse_();\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s5 = peg$c13;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e32); }\n        }\n        if (s5 !== peg$FAILED) {\n          s0 = peg$f9(s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      if (peg$silentFails === 0) { peg$fail(peg$e30); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsegameTerminationMarker() {\n    var s0, s1, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c14) {\n      s1 = peg$c14;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e34); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c15) {\n        s1 = peg$c15;\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e35); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 7) === peg$c16) {\n          s1 = peg$c16;\n          peg$currPos += 7;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e36); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s1 = peg$c17;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e37); }\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$parse_();\n      s3 = peg$parsecomment();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s0 = peg$f10(s1, s3);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e33); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    s1 = input.charAt(peg$currPos);\n    if (peg$r9.test(s1)) {\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e39); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = input.charAt(peg$currPos);\n      if (peg$r9.test(s1)) {\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e39); }\n      }\n    }\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e38); }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (options.peg$library) {\n    return /** @type {any} */ ({\n      peg$result,\n      peg$currPos,\n      peg$FAILED,\n      peg$maxFailExpected,\n      peg$maxFailPos\n    });\n  }\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nconst MASK64 = 0xffffffffffffffffn;\nfunction rotl(x, k) {\n    return ((x << k) | (x >> (64n - k))) & 0xffffffffffffffffn;\n}\nfunction wrappingMul(x, y) {\n    return (x * y) & MASK64;\n}\n// xoroshiro128**\nfunction xoroshiro128(state) {\n    return function () {\n        let s0 = BigInt(state & MASK64);\n        let s1 = BigInt((state >> 64n) & MASK64);\n        const result = wrappingMul(rotl(wrappingMul(s0, 5n), 7n), 9n);\n        s1 ^= s0;\n        s0 = (rotl(s0, 24n) ^ s1 ^ (s1 << 16n)) & MASK64;\n        s1 = rotl(s1, 37n);\n        state = (s1 << 64n) | s0;\n        return result;\n    };\n}\nconst rand = xoroshiro128(0xa187eb39cdcaed8f31c4b365b102e01en);\nconst PIECE_KEYS = Array.from({ length: 2 }, () => Array.from({ length: 6 }, () => Array.from({ length: 128 }, () => rand())));\nconst EP_KEYS = Array.from({ length: 8 }, () => rand());\nconst CASTLING_KEYS = Array.from({ length: 16 }, () => rand());\nconst SIDE_KEY = rand();\nconst WHITE = 'w';\nconst BLACK = 'b';\nconst PAWN = 'p';\nconst KNIGHT = 'n';\nconst BISHOP = 'b';\nconst ROOK = 'r';\nconst QUEEN = 'q';\nconst KING = 'k';\nconst DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nclass Move {\n    color;\n    from;\n    to;\n    piece;\n    captured;\n    promotion;\n    /**\n     * @deprecated This field is deprecated and will be removed in version 2.0.0.\n     * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\n     * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\n     * `isBigPawn`\n     */\n    flags;\n    san;\n    lan;\n    before;\n    after;\n    constructor(chess, internal) {\n        const { color, piece, from, to, flags, captured, promotion } = internal;\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        this.color = color;\n        this.piece = piece;\n        this.from = fromAlgebraic;\n        this.to = toAlgebraic;\n        /*\n         * HACK: The chess['_method']() calls below invoke private methods in the\n         * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n         * code cleaner elsewhere.\n         */\n        this.san = chess['_moveToSan'](internal, chess['_moves']({ legal: true }));\n        this.lan = fromAlgebraic + toAlgebraic;\n        this.before = chess.fen();\n        // Generate the FEN for the 'after' key\n        chess['_makeMove'](internal);\n        this.after = chess.fen();\n        chess['_undoMove']();\n        // Build the text representation of the move flags\n        this.flags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                this.flags += FLAGS[flag];\n            }\n        }\n        if (captured) {\n            this.captured = captured;\n        }\n        if (promotion) {\n            this.promotion = promotion;\n            this.lan += promotion;\n        }\n    }\n    isCapture() {\n        return this.flags.indexOf(FLAGS['CAPTURE']) > -1;\n    }\n    isPromotion() {\n        return this.flags.indexOf(FLAGS['PROMOTION']) > -1;\n    }\n    isEnPassant() {\n        return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1;\n    }\n    isKingsideCastle() {\n        return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1;\n    }\n    isQueensideCastle() {\n        return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1;\n    }\n    isBigPawn() {\n        return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1;\n    }\n}\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n    NULL_MOVE: '-',\n};\n// prettier-ignore\nconst SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n    NULL_MOVE: 128,\n};\n/* eslint-disable @typescript-eslint/naming-convention */\n// these are required, according to spec\nconst SEVEN_TAG_ROSTER = {\n    Event: '?',\n    Site: '?',\n    Date: '????.??.??',\n    Round: '?',\n    White: '?',\n    Black: '?',\n    Result: '*',\n};\n/**\n * These nulls are placeholders to fix the order of tags (as they appear in PGN spec); null values will be\n * eliminated in getHeaders()\n */\nconst SUPLEMENTAL_TAGS = {\n    WhiteTitle: null,\n    BlackTitle: null,\n    WhiteElo: null,\n    BlackElo: null,\n    WhiteUSCF: null,\n    BlackUSCF: null,\n    WhiteNA: null,\n    BlackNA: null,\n    WhiteType: null,\n    BlackType: null,\n    EventDate: null,\n    EventSponsor: null,\n    Section: null,\n    Stage: null,\n    Board: null,\n    Opening: null,\n    Variation: null,\n    SubVariation: null,\n    ECO: null,\n    NIC: null,\n    Time: null,\n    UTCTime: null,\n    UTCDate: null,\n    TimeControl: null,\n    SetUp: null,\n    FEN: null,\n    Termination: null,\n    Annotator: null,\n    Mode: null,\n    PlyCount: null,\n};\nconst HEADER_TEMPLATE = {\n    ...SEVEN_TAG_ROSTER,\n    ...SUPLEMENTAL_TAGS,\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [KING]: BITS.KSIDE_CASTLE,\n    [QUEEN]: BITS.QSIDE_CASTLE,\n};\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst SAN_NULLMOVE = '--';\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nfunction validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    // 9th criterion: is en-passant square legal?\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: some pawns are on the edge rows',\n        };\n    }\n    return { ok: true };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nclass Chess {\n    _board = new Array(128);\n    _turn = WHITE;\n    _header = {};\n    _kings = { w: EMPTY, b: EMPTY };\n    _epSquare = -1;\n    _halfMoves = 0;\n    _moveNumber = 0;\n    _history = [];\n    _comments = {};\n    _castling = { w: 0, b: 0 };\n    _hash = 0n;\n    // tracks number of times a position has been seen for repetition checking\n    _positionCount = new Map();\n    constructor(fen = DEFAULT_POSITION, { skipValidation = false } = {}) {\n        this.load(fen, { skipValidation });\n    }\n    clear({ preserveHeaders = false } = {}) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : { ...HEADER_TEMPLATE };\n        this._hash = this._computeHash();\n        this._positionCount = new Map();\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */\n        this._header['SetUp'] = null;\n        this._header['FEN'] = null;\n    }\n    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok, error } = validateFen(fen);\n            if (!ok) {\n                throw new Error(error);\n            }\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({ preserveHeaders });\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? WHITE : BLACK;\n                this._put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._hash = this._computeHash();\n        this._updateSetup(fen);\n        this._incPositionCount();\n    }\n    fen({ forceEnpassantSquare = false, } = {}) {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            if (forceEnpassantSquare) {\n                epSquare = algebraic(this._epSquare);\n            }\n            else {\n                const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n                const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n                for (const square of squares) {\n                    // is the square off the board?\n                    if (square & 0x88) {\n                        continue;\n                    }\n                    const color = this._turn;\n                    // is there a pawn that can capture the epSquare?\n                    if (this._board[square]?.color === color &&\n                        this._board[square]?.type === PAWN) {\n                        // if the pawn makes an ep capture, does it leave its king in check?\n                        this._makeMove({\n                            color,\n                            from: square,\n                            to: this._epSquare,\n                            piece: PAWN,\n                            captured: PAWN,\n                            flags: BITS.EP_CAPTURE,\n                        });\n                        const isLegal = !this._isKingAttacked(color);\n                        this._undoMove();\n                        // if ep is legal, break and set the ep square in the FEN output\n                        if (isLegal) {\n                            epSquare = algebraic(this._epSquare);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    _pieceKey(i) {\n        if (!this._board[i]) {\n            return 0n;\n        }\n        const { color, type } = this._board[i];\n        const colorIndex = {\n            w: 0,\n            b: 1,\n        }[color];\n        const typeIndex = {\n            p: 0,\n            n: 1,\n            b: 2,\n            r: 3,\n            q: 4,\n            k: 5,\n        }[type];\n        return PIECE_KEYS[colorIndex][typeIndex][i];\n    }\n    _epKey() {\n        return this._epSquare === EMPTY ? 0n : EP_KEYS[this._epSquare & 7];\n    }\n    _castlingKey() {\n        const index = (this._castling.w >> 5) | (this._castling.b >> 3);\n        return CASTLING_KEYS[index];\n    }\n    _computeHash() {\n        let hash = 0n;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            if (this._board[i]) {\n                hash ^= this._pieceKey(i);\n            }\n        }\n        hash ^= this._epKey();\n        hash ^= this._castlingKey();\n        if (this._turn === 'b') {\n            hash ^= SIDE_KEY;\n        }\n        return hash;\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            this._header['SetUp'] = null;\n            this._header['FEN'] = null;\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]];\n    }\n    findPiece(piece) {\n        const squares = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (!this._board[i] || this._board[i]?.color !== piece.color) {\n                continue;\n            }\n            // check if square contains the requested piece\n            if (this._board[i].color === piece.color &&\n                this._board[i].type === piece.type) {\n                squares.push(algebraic(i));\n            }\n        }\n        return squares;\n    }\n    put({ type, color }, square) {\n        if (this._put({ type, color }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _set(sq, piece) {\n        this._hash ^= this._pieceKey(sq);\n        this._board[sq] = piece;\n        this._hash ^= this._pieceKey(sq);\n    }\n    _put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n            this._kings[currentPieceOnSquare.color] = EMPTY;\n        }\n        this._set(sq, { type: type, color: color });\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        return true;\n    }\n    _clear(sq) {\n        this._hash ^= this._pieceKey(sq);\n        delete this._board[sq];\n    }\n    remove(square) {\n        const piece = this.get(square);\n        this._clear(Ox88[square]);\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        this._hash ^= this._castlingKey();\n        const whiteKingInPlace = this._board[Ox88.e1]?.type === KING &&\n            this._board[Ox88.e1]?.color === WHITE;\n        const blackKingInPlace = this._board[Ox88.e8]?.type === KING &&\n            this._board[Ox88.e8]?.color === BLACK;\n        if (!whiteKingInPlace ||\n            this._board[Ox88.a1]?.type !== ROOK ||\n            this._board[Ox88.a1]?.color !== WHITE) {\n            this._castling.w &= -65;\n        }\n        if (!whiteKingInPlace ||\n            this._board[Ox88.h1]?.type !== ROOK ||\n            this._board[Ox88.h1]?.color !== WHITE) {\n            this._castling.w &= -33;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.a8]?.type !== ROOK ||\n            this._board[Ox88.a8]?.color !== BLACK) {\n            this._castling.b &= -65;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.h8]?.type !== ROOK ||\n            this._board[Ox88.h8]?.color !== BLACK) {\n            this._castling.b &= -33;\n        }\n        this._hash ^= this._castlingKey();\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const attackers = [currentSquare + 1, currentSquare - 1];\n        if (this._board[startSquare] !== null ||\n            this._board[this._epSquare] !== null ||\n            this._board[currentSquare]?.color !== swapColor(this._turn) ||\n            this._board[currentSquare]?.type !== PAWN) {\n            this._hash ^= this._epKey();\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square) => !(square & 0x88) &&\n            this._board[square]?.color === this._turn &&\n            this._board[square]?.type === PAWN;\n        if (!attackers.some(canCapture)) {\n            this._hash ^= this._epKey();\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square, verbose) {\n        const attackers = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if ((difference > 0 && piece.color === WHITE) ||\n                        (difference <= 0 && piece.color === BLACK)) {\n                        if (!verbose) {\n                            return true;\n                        }\n                        else {\n                            attackers.push(algebraic(i));\n                        }\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k') {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked) {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n            }\n        }\n        if (verbose) {\n            return attackers;\n        }\n        else {\n            return false;\n        }\n    }\n    attackers(square, attackedBy) {\n        if (!attackedBy) {\n            return this._attacked(this._turn, Ox88[square], true);\n        }\n        else {\n            return this._attacked(attackedBy, Ox88[square], true);\n        }\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    hash() {\n        return this._hash.toString(16);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this._hash) >= 3;\n    }\n    isDrawByFiftyMoves() {\n        return this._halfMoves >= 100; // 50 moves per side = 100 half moves\n    }\n    isDraw() {\n        return (this.isDrawByFiftyMoves() ||\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\n        const moves = this._moves({ square, piece });\n        if (verbose) {\n            return moves.map((move) => new Move(this, move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (this._board[to]?.color === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === KNIGHT || type === KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (move === null) {\n            moveObj = this._moveFromSan(SAN_NULLMOVE, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        //disallow null moves when in check\n        if (this.isCheck() && moveObj.flags & BITS.NULL_MOVE) {\n            throw new Error('Null move not allowed when in check');\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = new Move(this, moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount();\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _movePiece(from, to) {\n        this._hash ^= this._pieceKey(from);\n        this._board[to] = this._board[from];\n        delete this._board[from];\n        this._hash ^= this._pieceKey(to);\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        if (move.flags & BITS.NULL_MOVE) {\n            if (us === BLACK) {\n                this._moveNumber++;\n            }\n            this._halfMoves++;\n            this._turn = them;\n            this._epSquare = EMPTY;\n            return;\n        }\n        this._hash ^= this._epKey();\n        this._hash ^= this._castlingKey();\n        if (move.captured) {\n            this._hash ^= this._pieceKey(move.to);\n        }\n        this._movePiece(move.from, move.to);\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                this._clear(move.to - 16);\n            }\n            else {\n                this._clear(move.to + 16);\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._clear(move.to);\n            this._set(move.to, { type: move.promotion, color: us });\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._movePiece(castlingFrom, castlingTo);\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._movePiece(castlingFrom, castlingTo);\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        this._hash ^= this._castlingKey();\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            let epSquare;\n            if (us === BLACK) {\n                epSquare = move.to - 16;\n            }\n            else {\n                epSquare = move.to + 16;\n            }\n            if ((!((move.to - 1) & 0x88) &&\n                this._board[move.to - 1]?.type === PAWN &&\n                this._board[move.to - 1]?.color === them) ||\n                (!((move.to + 1) & 0x88) &&\n                    this._board[move.to + 1]?.type === PAWN &&\n                    this._board[move.to + 1]?.color === them)) {\n                this._epSquare = epSquare;\n                this._hash ^= this._epKey();\n            }\n            else {\n                this._epSquare = EMPTY;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n        this._hash ^= SIDE_KEY;\n    }\n    undo() {\n        const hash = this._hash;\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = new Move(this, move);\n            this._decPositionCount(hash);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        this._hash ^= this._epKey();\n        this._hash ^= this._castlingKey();\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        this._hash ^= this._epKey();\n        this._hash ^= this._castlingKey();\n        this._hash ^= SIDE_KEY;\n        const us = this._turn;\n        const them = swapColor(us);\n        if (move.flags & BITS.NULL_MOVE) {\n            return move;\n        }\n        this._movePiece(move.to, move.from);\n        // to undo any promotions\n        if (move.piece) {\n            this._clear(move.from);\n            this._set(move.from, { type: move.piece, color: us });\n        }\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._set(index, { type: PAWN, color: them });\n            }\n            else {\n                // regular capture\n                this._set(move.to, { type: move.captured, color: them });\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._movePiece(castlingFrom, castlingTo);\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             *\n             * By using HEADER_TEMPLATE, the order of tags should be preserved; we\n             * do have to check for null placeholders, though, and omit them\n             */\n            const headerTag = this._header[i];\n            if (headerTag)\n                result.push(`[${i} \"${this._header[i]}\"]` + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result? (there ALWAYS has to be a result according to spec; see Seven Tag Roster)\n        moves.push(this._header.Result || '*');\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    /**\n     * @deprecated Use `setHeader` and `getHeaders` instead. This method will return null header tags (which is not what you want)\n     */\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    // TODO: value validation per spec\n    setHeader(key, value) {\n        this._header[key] = value ?? SEVEN_TAG_ROSTER[key] ?? null;\n        return this.getHeaders();\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            this._header[key] = SEVEN_TAG_ROSTER[key] || null;\n            return true;\n        }\n        return false;\n    }\n    // return only non-null headers (omit placemarker nulls)\n    getHeaders() {\n        const nonNullHeaders = {};\n        for (const [key, value] of Object.entries(this._header)) {\n            if (value !== null) {\n                nonNullHeaders[key] = value;\n            }\n        }\n        return nonNullHeaders;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        // If newlineChar is not the default, replace all instances with \\n\n        if (newlineChar !== '\\r?\\n') {\n            pgn = pgn.replace(new RegExp(newlineChar, 'g'), '\\n');\n        }\n        const parsedPgn = peg$parse(pgn);\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsedPgn.headers;\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, { preserveHeaders: true });\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // don't clear the headers when loading\n                this.load(headers['FEN'], { preserveHeaders: true });\n            }\n        }\n        let node = parsedPgn.root;\n        while (node) {\n            if (node.move) {\n                const move = this._moveFromSan(node.move, strict);\n                if (move == null) {\n                    throw new Error(`Invalid move in PGN: ${node.move}`);\n                }\n                else {\n                    this._makeMove(move);\n                    this._incPositionCount();\n                }\n            }\n            if (node.comment !== undefined) {\n                this._comments[this.fen()] = node.comment;\n            }\n            node = node.variations[0];\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        const result = parsedPgn.result;\n        if (result &&\n            Object.keys(this._header).length &&\n            this._header['Result'] !== result) {\n            this.setHeader('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else if (move.flags & BITS.NULL_MOVE) {\n            return SAN_NULLMOVE;\n        }\n        else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        let cleanMove = strippedSan(move);\n        if (!strict) {\n            if (cleanMove === '0-0') {\n                cleanMove = 'O-O';\n            }\n            else if (cleanMove === '0-0-0') {\n                cleanMove = 'O-O-O';\n            }\n        }\n        //first implementation of null with a dummy move (black king moves from a8 to a8), maybe this can be implemented better\n        if (cleanMove == SAN_NULLMOVE) {\n            const res = {\n                color: this._turn,\n                from: 0,\n                to: 0,\n                piece: 'k',\n                flags: BITS.NULL_MOVE,\n            };\n            return res;\n        }\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        if (!to) {\n            return null;\n        }\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove ===\n                    strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n                    return moves[i];\n                }\n                // hand-compare move properties with the results from our permissive regex\n            }\n            else if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                Ox88[from] == moves[i].from &&\n                Ox88[to] == moves[i].to &&\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            }\n            else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */\n                const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[to] == moves[i].to &&\n                    (from == square[0] || from == square[1]) &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    setTurn(color) {\n        if (this._turn == color) {\n            return false;\n        }\n        this.move('--');\n        return true;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(new Move(this, move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. Old positions are removed from the map if their counts are reduced to 0.\n     */\n    _getPositionCount(hash) {\n        return this._positionCount.get(hash) ?? 0;\n    }\n    _incPositionCount() {\n        this._positionCount.set(this._hash, (this._positionCount.get(this._hash) ?? 0) + 1);\n    }\n    _decPositionCount(hash) {\n        const currentCount = this._positionCount.get(hash) ?? 0;\n        if (currentCount === 1) {\n            this._positionCount.delete(hash);\n        }\n        else {\n            this._positionCount.set(hash, currentCount - 1);\n        }\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    /**\n     * @deprecated Renamed to `removeComment` for consistency\n     */\n    deleteComment() {\n        return this.removeComment();\n    }\n    removeComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    /**\n     * @deprecated Renamed to `removeComments` for consistency\n     */\n    deleteComments() {\n        return this.removeComments();\n    }\n    removeComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [KING, QUEEN]) {\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                }\n                else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return ((rights[KING] === undefined || rights[KING] === result[KING]) &&\n            (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]));\n    }\n    getCastlingRights(color) {\n        return {\n            [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n            [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n}\n\n\n//# sourceMappingURL=chess.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGVzcy5qc0AxLjQuMC9ub2RlX21vZHVsZXMvY2hlc3MuanMvZGlzdC9lc20vY2hlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQSwrQkFBK0IsMEJBQTBCLElBQUk7QUFDN0Q7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcscUJBQXFCLFdBQVcscUJBQXFCLGFBQWE7QUFDN0csNkJBQTZCLFdBQVc7QUFDeEMsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBDQUEwQztBQUNwRCxVQUFVLDBDQUEwQztBQUNwRDtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVSwwQ0FBMEM7QUFDcEQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkIsd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQTBELElBQUk7QUFDMUUsb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVEQUF1RCxJQUFJO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlDQUF5QyxJQUFJO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1QkFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQixJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNKO0FBQ3RKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGVzcy5qc0AxLjQuMC9ub2RlX21vZHVsZXMvY2hlc3MuanMvZGlzdC9lc20vY2hlc3MuanM/MjJjYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZ2VuZXJhdGVkIGJ5IFBlZ2d5IDQuMi4wLlxuLy9cbi8vIGh0dHBzOi8vcGVnZ3lqcy5vcmcvXG5cblxuXG4gIGZ1bmN0aW9uIHJvb3ROb2RlKGNvbW1lbnQpIHtcbiAgXHRyZXR1cm4gY29tbWVudCAhPT0gbnVsbCA/IHsgY29tbWVudCwgdmFyaWF0aW9uczogW10gfSA6IHsgdmFyaWF0aW9uczogW119XG4gIH1cblxuICBmdW5jdGlvbiBub2RlKG1vdmUsIHN1ZmZpeCwgbmFnLCBjb21tZW50LCB2YXJpYXRpb25zKSB7XG4gIFx0Y29uc3Qgbm9kZSA9IHsgbW92ZSwgdmFyaWF0aW9ucyB9O1xuXG4gICAgaWYgKHN1ZmZpeCkge1xuICAgIFx0bm9kZS5zdWZmaXggPSBzdWZmaXg7XG4gICAgfVxuXG4gICAgaWYgKG5hZykge1xuICAgIFx0bm9kZS5uYWcgPSBuYWc7XG4gICAgfVxuXG4gICAgaWYgKGNvbW1lbnQgIT09IG51bGwpIHtcbiAgICBcdG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmVUb1RyZWUoLi4ubm9kZXMpIHtcbiAgXHRjb25zdCBbcm9vdCwgLi4ucmVzdF0gPSBub2RlcztcblxuICAgIGxldCBwYXJlbnQgPSByb290O1xuXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiByZXN0KSB7XG4gICAgXHRpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgXHRwYXJlbnQudmFyaWF0aW9ucyA9IFtjaGlsZCwgLi4uY2hpbGQudmFyaWF0aW9uc107XG4gICAgICAgICAgICBjaGlsZC52YXJpYXRpb25zID0gW107XG4gICAgICAgICAgICBwYXJlbnQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH1cblxuICBcdHJldHVybiByb290XG4gIH1cblxuICBmdW5jdGlvbiBwZ24oaGVhZGVycywgZ2FtZSkge1xuICBcdGlmIChnYW1lLm1hcmtlciAmJiBnYW1lLm1hcmtlci5jb21tZW50KSB7XG4gICAgXHRsZXQgbm9kZSA9IGdhbWUucm9vdDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgXHRjb25zdCBuZXh0ID0gbm9kZS52YXJpYXRpb25zWzBdO1xuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBcdG5vZGUuY29tbWVudCA9IGdhbWUubWFya2VyLmNvbW1lbnQ7XG4gICAgICAgICAgICBcdGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICBcdHJldHVybiB7XG4gICAgXHRoZWFkZXJzLFxuICAgICAgICByb290OiBnYW1lLnJvb3QsXG4gICAgICAgIHJlc3VsdDogKGdhbWUubWFya2VyICYmIGdhbWUubWFya2VyLnJlc3VsdCkgPz8gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbmZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7XG4gIGZ1bmN0aW9uIEMoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfVxuICBDLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBDKCk7XG59XG5cbmZ1bmN0aW9uIHBlZyRTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIGxvY2F0aW9uKSB7XG4gIHZhciBzZWxmID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQgQ2hlY2sgaXMgYSBuZWNlc3NhcnkgZXZpbCB0byBzdXBwb3J0IG9sZGVyIGVudmlyb25tZW50c1xuICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHNlbGYsIHBlZyRTeW50YXhFcnJvci5wcm90b3R5cGUpO1xuICB9XG4gIHNlbGYuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgc2VsZi5mb3VuZCA9IGZvdW5kO1xuICBzZWxmLmxvY2F0aW9uID0gbG9jYXRpb247XG4gIHNlbGYubmFtZSA9IFwiU3ludGF4RXJyb3JcIjtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbnBlZyRzdWJjbGFzcyhwZWckU3ludGF4RXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcGVnJHBhZEVuZChzdHIsIHRhcmdldExlbmd0aCwgcGFkU3RyaW5nKSB7XG4gIHBhZFN0cmluZyA9IHBhZFN0cmluZyB8fCBcIiBcIjtcbiAgaWYgKHN0ci5sZW5ndGggPiB0YXJnZXRMZW5ndGgpIHsgcmV0dXJuIHN0cjsgfVxuICB0YXJnZXRMZW5ndGggLT0gc3RyLmxlbmd0aDtcbiAgcGFkU3RyaW5nICs9IHBhZFN0cmluZy5yZXBlYXQodGFyZ2V0TGVuZ3RoKTtcbiAgcmV0dXJuIHN0ciArIHBhZFN0cmluZy5zbGljZSgwLCB0YXJnZXRMZW5ndGgpO1xufVxuXG5wZWckU3ludGF4RXJyb3IucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKHNvdXJjZXMpIHtcbiAgdmFyIHN0ciA9IFwiRXJyb3I6IFwiICsgdGhpcy5tZXNzYWdlO1xuICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgIHZhciBzcmMgPSBudWxsO1xuICAgIHZhciBrO1xuICAgIGZvciAoayA9IDA7IGsgPCBzb3VyY2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICBpZiAoc291cmNlc1trXS5zb3VyY2UgPT09IHRoaXMubG9jYXRpb24uc291cmNlKSB7XG4gICAgICAgIHNyYyA9IHNvdXJjZXNba10udGV4dC5zcGxpdCgvXFxyXFxufFxcbnxcXHIvZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcyA9IHRoaXMubG9jYXRpb24uc3RhcnQ7XG4gICAgdmFyIG9mZnNldF9zID0gKHRoaXMubG9jYXRpb24uc291cmNlICYmICh0eXBlb2YgdGhpcy5sb2NhdGlvbi5zb3VyY2Uub2Zmc2V0ID09PSBcImZ1bmN0aW9uXCIpKVxuICAgICAgPyB0aGlzLmxvY2F0aW9uLnNvdXJjZS5vZmZzZXQocylcbiAgICAgIDogcztcbiAgICB2YXIgbG9jID0gdGhpcy5sb2NhdGlvbi5zb3VyY2UgKyBcIjpcIiArIG9mZnNldF9zLmxpbmUgKyBcIjpcIiArIG9mZnNldF9zLmNvbHVtbjtcbiAgICBpZiAoc3JjKSB7XG4gICAgICB2YXIgZSA9IHRoaXMubG9jYXRpb24uZW5kO1xuICAgICAgdmFyIGZpbGxlciA9IHBlZyRwYWRFbmQoXCJcIiwgb2Zmc2V0X3MubGluZS50b1N0cmluZygpLmxlbmd0aCwgJyAnKTtcbiAgICAgIHZhciBsaW5lID0gc3JjW3MubGluZSAtIDFdO1xuICAgICAgdmFyIGxhc3QgPSBzLmxpbmUgPT09IGUubGluZSA/IGUuY29sdW1uIDogbGluZS5sZW5ndGggKyAxO1xuICAgICAgdmFyIGhhdExlbiA9IChsYXN0IC0gcy5jb2x1bW4pIHx8IDE7XG4gICAgICBzdHIgKz0gXCJcXG4gLS0+IFwiICsgbG9jICsgXCJcXG5cIlxuICAgICAgICAgICsgZmlsbGVyICsgXCIgfFxcblwiXG4gICAgICAgICAgKyBvZmZzZXRfcy5saW5lICsgXCIgfCBcIiArIGxpbmUgKyBcIlxcblwiXG4gICAgICAgICAgKyBmaWxsZXIgKyBcIiB8IFwiICsgcGVnJHBhZEVuZChcIlwiLCBzLmNvbHVtbiAtIDEsICcgJylcbiAgICAgICAgICArIHBlZyRwYWRFbmQoXCJcIiwgaGF0TGVuLCBcIl5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSBcIlxcbiBhdCBcIiArIGxvYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbnBlZyRTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UgPSBmdW5jdGlvbihleHBlY3RlZCwgZm91bmQpIHtcbiAgdmFyIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOUyA9IHtcbiAgICBsaXRlcmFsOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgcmV0dXJuIFwiXFxcIlwiICsgbGl0ZXJhbEVzY2FwZShleHBlY3RhdGlvbi50ZXh0KSArIFwiXFxcIlwiO1xuICAgIH0sXG5cbiAgICBjbGFzczogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgIHZhciBlc2NhcGVkUGFydHMgPSBleHBlY3RhdGlvbi5wYXJ0cy5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXJ0KVxuICAgICAgICAgID8gY2xhc3NFc2NhcGUocGFydFswXSkgKyBcIi1cIiArIGNsYXNzRXNjYXBlKHBhcnRbMV0pXG4gICAgICAgICAgOiBjbGFzc0VzY2FwZShwYXJ0KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gXCJbXCIgKyAoZXhwZWN0YXRpb24uaW52ZXJ0ZWQgPyBcIl5cIiA6IFwiXCIpICsgZXNjYXBlZFBhcnRzLmpvaW4oXCJcIikgKyBcIl1cIjtcbiAgICB9LFxuXG4gICAgYW55OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcImFueSBjaGFyYWN0ZXJcIjtcbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcImVuZCBvZiBpbnB1dFwiO1xuICAgIH0sXG5cbiAgICBvdGhlcjogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgIHJldHVybiBleHBlY3RhdGlvbi5kZXNjcmlwdGlvbjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaGV4KGNoKSB7XG4gICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXRlcmFsRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKVxuICAgICAgLnJlcGxhY2UoL1wiL2csICBcIlxcXFxcXFwiXCIpXG4gICAgICAucmVwbGFjZSgvXFwwL2csIFwiXFxcXDBcIilcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpXG4gICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIilcbiAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MEZdL2csICAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiBcIlxcXFx4MFwiICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuIFwiXFxcXHhcIiAgKyBoZXgoY2gpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKVxuICAgICAgLnJlcGxhY2UoL1xcXS9nLCBcIlxcXFxdXCIpXG4gICAgICAucmVwbGFjZSgvXFxeL2csIFwiXFxcXF5cIilcbiAgICAgIC5yZXBsYWNlKC8tL2csICBcIlxcXFwtXCIpXG4gICAgICAucmVwbGFjZSgvXFwwL2csIFwiXFxcXDBcIilcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpXG4gICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIilcbiAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MEZdL2csICAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiBcIlxcXFx4MFwiICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuIFwiXFxcXHhcIiAgKyBoZXgoY2gpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc2NyaWJlRXhwZWN0YXRpb24oZXhwZWN0YXRpb24pIHtcbiAgICByZXR1cm4gREVTQ1JJQkVfRVhQRUNUQVRJT05fRk5TW2V4cGVjdGF0aW9uLnR5cGVdKGV4cGVjdGF0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc2NyaWJlRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICB2YXIgZGVzY3JpcHRpb25zID0gZXhwZWN0ZWQubWFwKGRlc2NyaWJlRXhwZWN0YXRpb24pO1xuICAgIHZhciBpLCBqO1xuXG4gICAgZGVzY3JpcHRpb25zLnNvcnQoKTtcblxuICAgIGlmIChkZXNjcmlwdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChpID0gMSwgaiA9IDE7IGkgPCBkZXNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uc1tpIC0gMV0gIT09IGRlc2NyaXB0aW9uc1tpXSkge1xuICAgICAgICAgIGRlc2NyaXB0aW9uc1tqXSA9IGRlc2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlc2NyaXB0aW9ucy5sZW5ndGggPSBqO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGVzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zWzBdO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF0gKyBcIiBvciBcIiArIGRlc2NyaXB0aW9uc1sxXTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9ucy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgKyBcIiwgb3IgXCJcbiAgICAgICAgICArIGRlc2NyaXB0aW9uc1tkZXNjcmlwdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzY3JpYmVGb3VuZChmb3VuZCkge1xuICAgIHJldHVybiBmb3VuZCA/IFwiXFxcIlwiICsgbGl0ZXJhbEVzY2FwZShmb3VuZCkgKyBcIlxcXCJcIiA6IFwiZW5kIG9mIGlucHV0XCI7XG4gIH1cblxuICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGRlc2NyaWJlRXhwZWN0ZWQoZXhwZWN0ZWQpICsgXCIgYnV0IFwiICsgZGVzY3JpYmVGb3VuZChmb3VuZCkgKyBcIiBmb3VuZC5cIjtcbn07XG5cbmZ1bmN0aW9uIHBlZyRwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucyA6IHt9O1xuXG4gIHZhciBwZWckRkFJTEVEID0ge307XG4gIHZhciBwZWckc291cmNlID0gb3B0aW9ucy5ncmFtbWFyU291cmNlO1xuXG4gIHZhciBwZWckc3RhcnRSdWxlRnVuY3Rpb25zID0geyBwZ246IHBlZyRwYXJzZXBnbiB9O1xuICB2YXIgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHBhcnNlcGduO1xuXG4gIHZhciBwZWckYzAgPSBcIltcIjtcbiAgdmFyIHBlZyRjMSA9IFwiXFxcIlwiO1xuICB2YXIgcGVnJGMyID0gXCJdXCI7XG4gIHZhciBwZWckYzMgPSBcIi5cIjtcbiAgdmFyIHBlZyRjNCA9IFwiTy1PLU9cIjtcbiAgdmFyIHBlZyRjNSA9IFwiTy1PXCI7XG4gIHZhciBwZWckYzYgPSBcIjAtMC0wXCI7XG4gIHZhciBwZWckYzcgPSBcIjAtMFwiO1xuICB2YXIgcGVnJGM4ID0gXCIkXCI7XG4gIHZhciBwZWckYzkgPSBcIntcIjtcbiAgdmFyIHBlZyRjMTAgPSBcIn1cIjtcbiAgdmFyIHBlZyRjMTEgPSBcIjtcIjtcbiAgdmFyIHBlZyRjMTIgPSBcIihcIjtcbiAgdmFyIHBlZyRjMTMgPSBcIilcIjtcbiAgdmFyIHBlZyRjMTQgPSBcIjEtMFwiO1xuICB2YXIgcGVnJGMxNSA9IFwiMC0xXCI7XG4gIHZhciBwZWckYzE2ID0gXCIxLzItMS8yXCI7XG4gIHZhciBwZWckYzE3ID0gXCIqXCI7XG5cbiAgdmFyIHBlZyRyMCA9IC9eW2EtekEtWl0vO1xuICB2YXIgcGVnJHIxID0gL15bXlwiXS87XG4gIHZhciBwZWckcjIgPSAvXlswLTldLztcbiAgdmFyIHBlZyRyMyA9IC9eWy5dLztcbiAgdmFyIHBlZyRyNCA9IC9eW2EtekEtWjEtOFxcLT1dLztcbiAgdmFyIHBlZyRyNSA9IC9eWysjXS87XG4gIHZhciBwZWckcjYgPSAvXlshP10vO1xuICB2YXIgcGVnJHI3ID0gL15bXn1dLztcbiAgdmFyIHBlZyRyOCA9IC9eW15cXHJcXG5dLztcbiAgdmFyIHBlZyRyOSA9IC9eWyBcXHRcXHJcXG5dLztcblxuICB2YXIgcGVnJGUwID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJ0YWcgcGFpclwiKTtcbiAgdmFyIHBlZyRlMSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJbXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJcXFwiXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJdXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlNCA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwidGFnIG5hbWVcIik7XG4gIHZhciBwZWckZTUgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiYVwiLCBcInpcIl0sIFtcIkFcIiwgXCJaXCJdXSwgZmFsc2UsIGZhbHNlKTtcbiAgdmFyIHBlZyRlNiA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwidGFnIHZhbHVlXCIpO1xuICB2YXIgcGVnJGU3ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiXFxcIlwiXSwgdHJ1ZSwgZmFsc2UpO1xuICB2YXIgcGVnJGU4ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJtb3ZlIG51bWJlclwiKTtcbiAgdmFyIHBlZyRlOSA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCIwXCIsIFwiOVwiXV0sIGZhbHNlLCBmYWxzZSk7XG4gIHZhciBwZWckZTEwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi5cIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUxMSA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIi5cIl0sIGZhbHNlLCBmYWxzZSk7XG4gIHZhciBwZWckZTEyID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJzdGFuZGFyZCBhbGdlYnJhaWMgbm90YXRpb25cIik7XG4gIHZhciBwZWckZTEzID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIk8tTy1PXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMTQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiTy1PXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMTUgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiMC0wLTBcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUxNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIwLTBcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUxNyA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl0sIFtcIjFcIiwgXCI4XCJdLCBcIi1cIiwgXCI9XCJdLCBmYWxzZSwgZmFsc2UpO1xuICB2YXIgcGVnJGUxOCA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIitcIiwgXCIjXCJdLCBmYWxzZSwgZmFsc2UpO1xuICB2YXIgcGVnJGUxOSA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwic3VmZml4IGFubm90YXRpb25cIik7XG4gIHZhciBwZWckZTIwID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiIVwiLCBcIj9cIl0sIGZhbHNlLCBmYWxzZSk7XG4gIHZhciBwZWckZTIxID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJOQUdcIik7XG4gIHZhciBwZWckZTIyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiRcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUyMyA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwiYnJhY2UgY29tbWVudFwiKTtcbiAgdmFyIHBlZyRlMjQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwie1wiLCBmYWxzZSk7XG4gIHZhciBwZWckZTI1ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wifVwiXSwgdHJ1ZSwgZmFsc2UpO1xuICB2YXIgcGVnJGUyNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ9XCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMjcgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcInJlc3Qgb2YgbGluZSBjb21tZW50XCIpO1xuICB2YXIgcGVnJGUyOCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI7XCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMjkgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCJcXHJcIiwgXCJcXG5cIl0sIHRydWUsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMzAgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcInZhcmlhdGlvblwiKTtcbiAgdmFyIHBlZyRlMzEgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKFwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTMyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIilcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUzMyA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwiZ2FtZSB0ZXJtaW5hdGlvbiBtYXJrZXJcIik7XG4gIHZhciBwZWckZTM0ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjEtMFwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTM1ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjAtMVwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTM2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjEvMi0xLzJcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUzNyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIqXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMzggPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcIndoaXRlc3BhY2VcIik7XG4gIHZhciBwZWckZTM5ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiIFwiLCBcIlxcdFwiLCBcIlxcclwiLCBcIlxcblwiXSwgZmFsc2UsIGZhbHNlKTtcblxuICB2YXIgcGVnJGYwID0gZnVuY3Rpb24oaGVhZGVycywgZ2FtZSkgeyByZXR1cm4gcGduKGhlYWRlcnMsIGdhbWUpIH07XG4gIHZhciBwZWckZjEgPSBmdW5jdGlvbih0YWdQYWlycykgeyByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRhZ1BhaXJzKSB9O1xuICB2YXIgcGVnJGYyID0gZnVuY3Rpb24odGFnTmFtZSwgdGFnVmFsdWUpIHsgcmV0dXJuIFt0YWdOYW1lLCB0YWdWYWx1ZV0gfTtcbiAgdmFyIHBlZyRmMyA9IGZ1bmN0aW9uKHJvb3QsIG1hcmtlcikgeyByZXR1cm4geyByb290LCBtYXJrZXJ9IH07XG4gIHZhciBwZWckZjQgPSBmdW5jdGlvbihjb21tZW50LCBtb3ZlcykgeyByZXR1cm4gbGluZVRvVHJlZShyb290Tm9kZShjb21tZW50KSwgLi4ubW92ZXMuZmxhdCgpKSB9O1xuICB2YXIgcGVnJGY1ID0gZnVuY3Rpb24oc2FuLCBzdWZmaXgsIG5hZywgY29tbWVudCwgdmFyaWF0aW9ucykgeyByZXR1cm4gbm9kZShzYW4sIHN1ZmZpeCwgbmFnLCBjb21tZW50LCB2YXJpYXRpb25zKSB9O1xuICB2YXIgcGVnJGY2ID0gZnVuY3Rpb24obmFnKSB7IHJldHVybiBuYWcgfTtcbiAgdmFyIHBlZyRmNyA9IGZ1bmN0aW9uKGNvbW1lbnQpIHsgcmV0dXJuIGNvbW1lbnQucmVwbGFjZSgvW1xcclxcbl0rL2csIFwiIFwiKSB9O1xuICB2YXIgcGVnJGY4ID0gZnVuY3Rpb24oY29tbWVudCkgeyByZXR1cm4gY29tbWVudC50cmltKCkgfTtcbiAgdmFyIHBlZyRmOSA9IGZ1bmN0aW9uKGxpbmUpIHsgcmV0dXJuIGxpbmUgfTtcbiAgdmFyIHBlZyRmMTAgPSBmdW5jdGlvbihyZXN1bHQsIGNvbW1lbnQpIHsgcmV0dXJuIHsgcmVzdWx0LCBjb21tZW50IH0gfTtcbiAgdmFyIHBlZyRjdXJyUG9zID0gb3B0aW9ucy5wZWckY3VyclBvcyB8IDA7XG4gIHZhciBwZWckcG9zRGV0YWlsc0NhY2hlID0gW3sgbGluZTogMSwgY29sdW1uOiAxIH1dO1xuICB2YXIgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgdmFyIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBvcHRpb25zLnBlZyRtYXhGYWlsRXhwZWN0ZWQgfHwgW107XG4gIHZhciBwZWckc2lsZW50RmFpbHMgPSBvcHRpb25zLnBlZyRzaWxlbnRGYWlscyB8IDA7XG5cbiAgdmFyIHBlZyRyZXN1bHQ7XG5cbiAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlKSB7XG4gICAgaWYgKCEob3B0aW9ucy5zdGFydFJ1bGUgaW4gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFwiLlwiKTtcbiAgICB9XG5cbiAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckc3RhcnRSdWxlRnVuY3Rpb25zW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24odGV4dCwgaWdub3JlQ2FzZSkge1xuICAgIHJldHVybiB7IHR5cGU6IFwibGl0ZXJhbFwiLCB0ZXh0OiB0ZXh0LCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY2xhc3NFeHBlY3RhdGlvbihwYXJ0cywgaW52ZXJ0ZWQsIGlnbm9yZUNhc2UpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImNsYXNzXCIsIHBhcnRzOiBwYXJ0cywgaW52ZXJ0ZWQ6IGludmVydGVkLCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckZW5kRXhwZWN0YXRpb24oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlbmRcIiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJG90aGVyRXhwZWN0YXRpb24oZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykge1xuICAgIHZhciBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdO1xuICAgIHZhciBwO1xuXG4gICAgaWYgKGRldGFpbHMpIHtcbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocG9zID49IHBlZyRwb3NEZXRhaWxzQ2FjaGUubGVuZ3RoKSB7XG4gICAgICAgIHAgPSBwZWckcG9zRGV0YWlsc0NhY2hlLmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwID0gcG9zO1xuICAgICAgICB3aGlsZSAoIXBlZyRwb3NEZXRhaWxzQ2FjaGVbLS1wXSkge31cbiAgICAgIH1cblxuICAgICAgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcF07XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBsaW5lOiBkZXRhaWxzLmxpbmUsXG4gICAgICAgIGNvbHVtbjogZGV0YWlscy5jb2x1bW5cbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChwIDwgcG9zKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHApID09PSAxMCkge1xuICAgICAgICAgIGRldGFpbHMubGluZSsrO1xuICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbisrO1xuICAgICAgICB9XG5cbiAgICAgICAgcCsrO1xuICAgICAgfVxuXG4gICAgICBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc10gPSBkZXRhaWxzO1xuXG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY29tcHV0ZUxvY2F0aW9uKHN0YXJ0UG9zLCBlbmRQb3MsIG9mZnNldCkge1xuICAgIHZhciBzdGFydFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoc3RhcnRQb3MpO1xuICAgIHZhciBlbmRQb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKGVuZFBvcyk7XG5cbiAgICB2YXIgcmVzID0ge1xuICAgICAgc291cmNlOiBwZWckc291cmNlLFxuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgb2Zmc2V0OiBzdGFydFBvcyxcbiAgICAgICAgbGluZTogc3RhcnRQb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIGNvbHVtbjogc3RhcnRQb3NEZXRhaWxzLmNvbHVtblxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBvZmZzZXQ6IGVuZFBvcyxcbiAgICAgICAgbGluZTogZW5kUG9zRGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IGVuZFBvc0RldGFpbHMuY29sdW1uXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGZhaWwoZXhwZWN0ZWQpIHtcbiAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgIGlmIChwZWckY3VyclBvcyA+IHBlZyRtYXhGYWlsUG9zKSB7XG4gICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgIH1cblxuICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoZXhwZWN0ZWQsIGZvdW5kLCBsb2NhdGlvbikge1xuICAgIHJldHVybiBuZXcgcGVnJFN5bnRheEVycm9yKFxuICAgICAgcGVnJFN5bnRheEVycm9yLmJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBmb3VuZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXBnbigpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2V0YWdQYWlyU2VjdGlvbigpO1xuICAgIHMyID0gcGVnJHBhcnNlbW92ZVRleHRTZWN0aW9uKCk7XG4gICAgczAgPSBwZWckZjAoczEsIHMyKTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXRhZ1BhaXJTZWN0aW9uKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIHMyID0gcGVnJHBhcnNldGFnUGFpcigpO1xuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEucHVzaChzMik7XG4gICAgICBzMiA9IHBlZyRwYXJzZXRhZ1BhaXIoKTtcbiAgICB9XG4gICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgczAgPSBwZWckZjEoczEpO1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNldGFnUGFpcigpIHtcbiAgICB2YXIgczAsIHMyLCBzNCwgczYsIHM3LCBzOCwgczEwO1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBwZWckcGFyc2VfKCk7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgczIgPSBwZWckYzA7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMSk7IH1cbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBwZWckcGFyc2VfKCk7XG4gICAgICBzNCA9IHBlZyRwYXJzZXRhZ05hbWUoKTtcbiAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcGFyc2VfKCk7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICBzNiA9IHBlZyRjMTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNyA9IHBlZyRwYXJzZXRhZ1ZhbHVlKCk7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNCkge1xuICAgICAgICAgICAgczggPSBwZWckYzE7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzOCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMik7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkzKSB7XG4gICAgICAgICAgICAgIHMxMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMxMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMxMCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRmMihzNCwgczcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUwKTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXRhZ05hbWUoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gW107XG4gICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgIGlmIChwZWckcjAudGVzdChzMikpIHtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU1KTsgfVxuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBpZiAocGVnJHIwLnRlc3QoczIpKSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTUpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gaW5wdXQuc3Vic3RyaW5nKHMwLCBwZWckY3VyclBvcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gczE7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTQpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNldGFnVmFsdWUoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gW107XG4gICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgIGlmIChwZWckcjEudGVzdChzMikpIHtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU3KTsgfVxuICAgIH1cbiAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxLnB1c2goczIpO1xuICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgaWYgKHBlZyRyMS50ZXN0KHMyKSkge1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlNyk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgczAgPSBpbnB1dC5zdWJzdHJpbmcoczAsIHBlZyRjdXJyUG9zKTtcbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTYpOyB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vtb3ZlVGV4dFNlY3Rpb24oKSB7XG4gICAgdmFyIHMwLCBzMSwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlbGluZSgpO1xuICAgIHBlZyRwYXJzZV8oKTtcbiAgICBzMyA9IHBlZyRwYXJzZWdhbWVUZXJtaW5hdGlvbk1hcmtlcigpO1xuICAgIGlmIChzMyA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczMgPSBudWxsO1xuICAgIH1cbiAgICBwZWckcGFyc2VfKCk7XG4gICAgczAgPSBwZWckZjMoczEsIHMzKTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWxpbmUoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZWNvbW1lbnQoKTtcbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gbnVsbDtcbiAgICB9XG4gICAgczIgPSBbXTtcbiAgICBzMyA9IHBlZyRwYXJzZW1vdmUoKTtcbiAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyLnB1c2goczMpO1xuICAgICAgczMgPSBwZWckcGFyc2Vtb3ZlKCk7XG4gICAgfVxuICAgIHMwID0gcGVnJGY0KHMxLCBzMik7XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vtb3ZlKCkge1xuICAgIHZhciBzMCwgczQsIHM1LCBzNiwgczcsIHM4LCBzOSwgczEwO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBwZWckcGFyc2VfKCk7XG4gICAgcGVnJHBhcnNlbW92ZU51bWJlcigpO1xuICAgIHBlZyRwYXJzZV8oKTtcbiAgICBzNCA9IHBlZyRwYXJzZXNhbigpO1xuICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczUgPSBwZWckcGFyc2VzdWZmaXhBbm5vdGF0aW9uKCk7XG4gICAgICBpZiAoczUgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczUgPSBudWxsO1xuICAgICAgfVxuICAgICAgczYgPSBbXTtcbiAgICAgIHM3ID0gcGVnJHBhcnNlbmFnKCk7XG4gICAgICB3aGlsZSAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczYucHVzaChzNyk7XG4gICAgICAgIHM3ID0gcGVnJHBhcnNlbmFnKCk7XG4gICAgICB9XG4gICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIHM4ID0gcGVnJHBhcnNlY29tbWVudCgpO1xuICAgICAgaWYgKHM4ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHM4ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHM5ID0gW107XG4gICAgICBzMTAgPSBwZWckcGFyc2V2YXJpYXRpb24oKTtcbiAgICAgIHdoaWxlIChzMTAgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczkucHVzaChzMTApO1xuICAgICAgICBzMTAgPSBwZWckcGFyc2V2YXJpYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHMwID0gcGVnJGY1KHM0LCBzNSwgczYsIHM4LCBzOSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbW92ZU51bWJlcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgaWYgKHBlZyRyMi50ZXN0KHMyKSkge1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTkpOyB9XG4gICAgfVxuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEucHVzaChzMik7XG4gICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBpZiAocGVnJHIyLnRlc3QoczIpKSB7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU5KTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ2KSB7XG4gICAgICBzMiA9IHBlZyRjMztcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxMCk7IH1cbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIHM0ID0gW107XG4gICAgICBzNSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBpZiAocGVnJHIzLnRlc3QoczUpKSB7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxMSk7IH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgczUgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBpZiAocGVnJHIzLnRlc3QoczUpKSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTExKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzMSA9IFtzMSwgczIsIHMzLCBzNF07XG4gICAgICBzMCA9IHMxO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU4KTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXNhbigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM0KSB7XG4gICAgICBzMiA9IHBlZyRjNDtcbiAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxMyk7IH1cbiAgICB9XG4gICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAzKSA9PT0gcGVnJGM1KSB7XG4gICAgICAgIHMyID0gcGVnJGM1O1xuICAgICAgICBwZWckY3VyclBvcyArPSAzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTQpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjNikge1xuICAgICAgICAgIHMyID0gcGVnJGM2O1xuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxNSk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAzKSA9PT0gcGVnJGM3KSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRjNztcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxNik7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgaWYgKHBlZyRyMC50ZXN0KHMzKSkge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlNSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgICAgICBzNSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgIGlmIChwZWckcjQudGVzdChzNSkpIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTcpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckcjQudGVzdChzNSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTE3KTsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczMgPSBbczMsIHM0XTtcbiAgICAgICAgICAgICAgICBzMiA9IHMzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczI7XG4gICAgICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xuICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgaWYgKHBlZyRyNS50ZXN0KHMzKSkge1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTgpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBudWxsO1xuICAgICAgfVxuICAgICAgczIgPSBbczIsIHMzXTtcbiAgICAgIHMxID0gczI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczE7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBpbnB1dC5zdWJzdHJpbmcoczAsIHBlZyRjdXJyUG9zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgczAgPSBzMTtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTIpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc3VmZml4QW5ub3RhdGlvbigpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgaWYgKHBlZyRyNi50ZXN0KHMyKSkge1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTIwKTsgfVxuICAgIH1cbiAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxLnB1c2goczIpO1xuICAgICAgaWYgKHMxLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgaWYgKHBlZyRyNi50ZXN0KHMyKSkge1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyMCk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoczEubGVuZ3RoIDwgMSkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9IGVsc2Uge1xuICAgICAgczAgPSBzMTtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTkpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbmFnKCkge1xuICAgIHZhciBzMCwgczIsIHMzLCBzNCwgczU7XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHBlZyRwYXJzZV8oKTtcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM2KSB7XG4gICAgICBzMiA9IHBlZyRjODtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyMik7IH1cbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgczQgPSBbXTtcbiAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIGlmIChwZWckcjIudGVzdChzNSkpIHtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTkpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQucHVzaChzNSk7XG4gICAgICAgICAgczUgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIGlmIChwZWckcjIudGVzdChzNSkpIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU5KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gaW5wdXQuc3Vic3RyaW5nKHMzLCBwZWckY3VyclBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMyA9IHM0O1xuICAgICAgfVxuICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGY2KHMzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjEpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlY29tbWVudCgpIHtcbiAgICB2YXIgczA7XG5cbiAgICBzMCA9IHBlZyRwYXJzZWJyYWNlQ29tbWVudCgpO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckcGFyc2VyZXN0T2ZMaW5lQ29tbWVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWJyYWNlQ29tbWVudCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyMykge1xuICAgICAgczEgPSBwZWckYzk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjQpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgIHMzID0gW107XG4gICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBpZiAocGVnJHI3LnRlc3QoczQpKSB7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyNSk7IH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBpZiAocGVnJHI3LnRlc3QoczQpKSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTI1KTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzMiA9IGlucHV0LnN1YnN0cmluZyhzMiwgcGVnJGN1cnJQb3MpO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjUpIHtcbiAgICAgICAgczMgPSBwZWckYzEwO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjYpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckZjcoczIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyMyk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VyZXN0T2ZMaW5lQ29tbWVudCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU5KSB7XG4gICAgICBzMSA9IHBlZyRjMTE7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjgpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgIHMzID0gW107XG4gICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBpZiAocGVnJHI4LnRlc3QoczQpKSB7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyOSk7IH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBpZiAocGVnJHI4LnRlc3QoczQpKSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTI5KTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzMiA9IGlucHV0LnN1YnN0cmluZyhzMiwgcGVnJGN1cnJQb3MpO1xuICAgICAgczAgPSBwZWckZjgoczIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyNyk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V2YXJpYXRpb24oKSB7XG4gICAgdmFyIHMwLCBzMiwgczMsIHM1O1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBwZWckcGFyc2VfKCk7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MCkge1xuICAgICAgczIgPSBwZWckYzEyO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTMxKTsgfVxuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMzID0gcGVnJHBhcnNlbGluZSgpO1xuICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRwYXJzZV8oKTtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MSkge1xuICAgICAgICAgIHM1ID0gcGVnJGMxMztcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMzIpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckZjkoczMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTMwKTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWdhbWVUZXJtaW5hdGlvbk1hcmtlcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMztcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMykgPT09IHBlZyRjMTQpIHtcbiAgICAgIHMxID0gcGVnJGMxNDtcbiAgICAgIHBlZyRjdXJyUG9zICs9IDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzNCk7IH1cbiAgICB9XG4gICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAzKSA9PT0gcGVnJGMxNSkge1xuICAgICAgICBzMSA9IHBlZyRjMTU7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzNSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA3KSA9PT0gcGVnJGMxNikge1xuICAgICAgICAgIHMxID0gcGVnJGMxNjtcbiAgICAgICAgICBwZWckY3VyclBvcyArPSA3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMzYpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Mikge1xuICAgICAgICAgICAgczEgPSBwZWckYzE3O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTM3KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRwYXJzZV8oKTtcbiAgICAgIHMzID0gcGVnJHBhcnNlY29tbWVudCgpO1xuICAgICAgaWYgKHMzID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHMwID0gcGVnJGYxMChzMSwgczMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzMyk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VfKCkge1xuICAgIHZhciBzMCwgczE7XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IFtdO1xuICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICBpZiAocGVnJHI5LnRlc3QoczEpKSB7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMzkpOyB9XG4gICAgfVxuICAgIHdoaWxlIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAucHVzaChzMSk7XG4gICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBpZiAocGVnJHI5LnRlc3QoczEpKSB7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzOSk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgczEgPSBwZWckRkFJTEVEO1xuICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzOCk7IH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcblxuICBpZiAob3B0aW9ucy5wZWckbGlicmFyeSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHtcbiAgICAgIHBlZyRyZXN1bHQsXG4gICAgICBwZWckY3VyclBvcyxcbiAgICAgIHBlZyRGQUlMRUQsXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLFxuICAgICAgcGVnJG1heEZhaWxQb3NcbiAgICB9KTtcbiAgfVxuICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHBlZyRmYWlsKHBlZyRlbmRFeHBlY3RhdGlvbigpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLFxuICAgICAgcGVnJG1heEZhaWxQb3MgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQocGVnJG1heEZhaWxQb3MpIDogbnVsbCxcbiAgICAgIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoXG4gICAgICAgID8gcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckbWF4RmFpbFBvcywgcGVnJG1heEZhaWxQb3MgKyAxKVxuICAgICAgICA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJG1heEZhaWxQb3MsIHBlZyRtYXhGYWlsUG9zKVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDI1LCBKZWZmIEhseXdhIChqaGx5d2FAZ21haWwuY29tKVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbmNvbnN0IE1BU0s2NCA9IDB4ZmZmZmZmZmZmZmZmZmZmZm47XG5mdW5jdGlvbiByb3RsKHgsIGspIHtcbiAgICByZXR1cm4gKCh4IDw8IGspIHwgKHggPj4gKDY0biAtIGspKSkgJiAweGZmZmZmZmZmZmZmZmZmZmZuO1xufVxuZnVuY3Rpb24gd3JhcHBpbmdNdWwoeCwgeSkge1xuICAgIHJldHVybiAoeCAqIHkpICYgTUFTSzY0O1xufVxuLy8geG9yb3NoaXJvMTI4KipcbmZ1bmN0aW9uIHhvcm9zaGlybzEyOChzdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBzMCA9IEJpZ0ludChzdGF0ZSAmIE1BU0s2NCk7XG4gICAgICAgIGxldCBzMSA9IEJpZ0ludCgoc3RhdGUgPj4gNjRuKSAmIE1BU0s2NCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHdyYXBwaW5nTXVsKHJvdGwod3JhcHBpbmdNdWwoczAsIDVuKSwgN24pLCA5bik7XG4gICAgICAgIHMxIF49IHMwO1xuICAgICAgICBzMCA9IChyb3RsKHMwLCAyNG4pIF4gczEgXiAoczEgPDwgMTZuKSkgJiBNQVNLNjQ7XG4gICAgICAgIHMxID0gcm90bChzMSwgMzduKTtcbiAgICAgICAgc3RhdGUgPSAoczEgPDwgNjRuKSB8IHMwO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5jb25zdCByYW5kID0geG9yb3NoaXJvMTI4KDB4YTE4N2ViMzljZGNhZWQ4ZjMxYzRiMzY1YjEwMmUwMWVuKTtcbmNvbnN0IFBJRUNFX0tFWVMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyIH0sICgpID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IDYgfSwgKCkgPT4gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTI4IH0sICgpID0+IHJhbmQoKSkpKTtcbmNvbnN0IEVQX0tFWVMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA4IH0sICgpID0+IHJhbmQoKSk7XG5jb25zdCBDQVNUTElOR19LRVlTID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTYgfSwgKCkgPT4gcmFuZCgpKTtcbmNvbnN0IFNJREVfS0VZID0gcmFuZCgpO1xuY29uc3QgV0hJVEUgPSAndyc7XG5jb25zdCBCTEFDSyA9ICdiJztcbmNvbnN0IFBBV04gPSAncCc7XG5jb25zdCBLTklHSFQgPSAnbic7XG5jb25zdCBCSVNIT1AgPSAnYic7XG5jb25zdCBST09LID0gJ3InO1xuY29uc3QgUVVFRU4gPSAncSc7XG5jb25zdCBLSU5HID0gJ2snO1xuY29uc3QgREVGQVVMVF9QT1NJVElPTiA9ICdybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMSc7XG5jbGFzcyBNb3ZlIHtcbiAgICBjb2xvcjtcbiAgICBmcm9tO1xuICAgIHRvO1xuICAgIHBpZWNlO1xuICAgIGNhcHR1cmVkO1xuICAgIHByb21vdGlvbjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGZpZWxkIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDIuMC4wLlxuICAgICAqIFBsZWFzZSB1c2UgbW92ZSBkZXNjcmlwdG9yIGZ1bmN0aW9ucyBpbnN0ZWFkOiBgaXNDYXB0dXJlYCwgYGlzUHJvbW90aW9uYCxcbiAgICAgKiBgaXNFblBhc3NhbnRgLCBgaXNLaW5nc2lkZUNhc3RsZWAsIGBpc1F1ZWVuc2lkZUNhc3RsZWAsIGBpc0Nhc3RsZWAsIGFuZFxuICAgICAqIGBpc0JpZ1Bhd25gXG4gICAgICovXG4gICAgZmxhZ3M7XG4gICAgc2FuO1xuICAgIGxhbjtcbiAgICBiZWZvcmU7XG4gICAgYWZ0ZXI7XG4gICAgY29uc3RydWN0b3IoY2hlc3MsIGludGVybmFsKSB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IsIHBpZWNlLCBmcm9tLCB0bywgZmxhZ3MsIGNhcHR1cmVkLCBwcm9tb3Rpb24gfSA9IGludGVybmFsO1xuICAgICAgICBjb25zdCBmcm9tQWxnZWJyYWljID0gYWxnZWJyYWljKGZyb20pO1xuICAgICAgICBjb25zdCB0b0FsZ2VicmFpYyA9IGFsZ2VicmFpYyh0byk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5waWVjZSA9IHBpZWNlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tQWxnZWJyYWljO1xuICAgICAgICB0aGlzLnRvID0gdG9BbGdlYnJhaWM7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEhBQ0s6IFRoZSBjaGVzc1snX21ldGhvZCddKCkgY2FsbHMgYmVsb3cgaW52b2tlIHByaXZhdGUgbWV0aG9kcyBpbiB0aGVcbiAgICAgICAgICogQ2hlc3MgY2xhc3MgdG8gZ2VuZXJhdGUgU0FOIGFuZCBGRU4uIEl0J3MgYSBiaXQgb2YgYSBoYWNrLCBidXQgbWFrZXMgdGhlXG4gICAgICAgICAqIGNvZGUgY2xlYW5lciBlbHNld2hlcmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNhbiA9IGNoZXNzWydfbW92ZVRvU2FuJ10oaW50ZXJuYWwsIGNoZXNzWydfbW92ZXMnXSh7IGxlZ2FsOiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5sYW4gPSBmcm9tQWxnZWJyYWljICsgdG9BbGdlYnJhaWM7XG4gICAgICAgIHRoaXMuYmVmb3JlID0gY2hlc3MuZmVuKCk7XG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSBGRU4gZm9yIHRoZSAnYWZ0ZXInIGtleVxuICAgICAgICBjaGVzc1snX21ha2VNb3ZlJ10oaW50ZXJuYWwpO1xuICAgICAgICB0aGlzLmFmdGVyID0gY2hlc3MuZmVuKCk7XG4gICAgICAgIGNoZXNzWydfdW5kb01vdmUnXSgpO1xuICAgICAgICAvLyBCdWlsZCB0aGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbW92ZSBmbGFnc1xuICAgICAgICB0aGlzLmZsYWdzID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgZmxhZyBpbiBCSVRTKSB7XG4gICAgICAgICAgICBpZiAoQklUU1tmbGFnXSAmIGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGFncyArPSBGTEFHU1tmbGFnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZWQgPSBjYXB0dXJlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbW90aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnByb21vdGlvbiA9IHByb21vdGlvbjtcbiAgICAgICAgICAgIHRoaXMubGFuICs9IHByb21vdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0NhcHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0NBUFRVUkUnXSkgPiAtMTtcbiAgICB9XG4gICAgaXNQcm9tb3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ1BST01PVElPTiddKSA+IC0xO1xuICAgIH1cbiAgICBpc0VuUGFzc2FudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snRVBfQ0FQVFVSRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc0tpbmdzaWRlQ2FzdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFncy5pbmRleE9mKEZMQUdTWydLU0lERV9DQVNUTEUnXSkgPiAtMTtcbiAgICB9XG4gICAgaXNRdWVlbnNpZGVDYXN0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ1FTSURFX0NBU1RMRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc0JpZ1Bhd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0JJR19QQVdOJ10pID4gLTE7XG4gICAgfVxufVxuY29uc3QgRU1QVFkgPSAtMTtcbmNvbnN0IEZMQUdTID0ge1xuICAgIE5PUk1BTDogJ24nLFxuICAgIENBUFRVUkU6ICdjJyxcbiAgICBCSUdfUEFXTjogJ2InLFxuICAgIEVQX0NBUFRVUkU6ICdlJyxcbiAgICBQUk9NT1RJT046ICdwJyxcbiAgICBLU0lERV9DQVNUTEU6ICdrJyxcbiAgICBRU0lERV9DQVNUTEU6ICdxJyxcbiAgICBOVUxMX01PVkU6ICctJyxcbn07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNRVUFSRVMgPSBbXG4gICAgJ2E4JywgJ2I4JywgJ2M4JywgJ2Q4JywgJ2U4JywgJ2Y4JywgJ2c4JywgJ2g4JyxcbiAgICAnYTcnLCAnYjcnLCAnYzcnLCAnZDcnLCAnZTcnLCAnZjcnLCAnZzcnLCAnaDcnLFxuICAgICdhNicsICdiNicsICdjNicsICdkNicsICdlNicsICdmNicsICdnNicsICdoNicsXG4gICAgJ2E1JywgJ2I1JywgJ2M1JywgJ2Q1JywgJ2U1JywgJ2Y1JywgJ2c1JywgJ2g1JyxcbiAgICAnYTQnLCAnYjQnLCAnYzQnLCAnZDQnLCAnZTQnLCAnZjQnLCAnZzQnLCAnaDQnLFxuICAgICdhMycsICdiMycsICdjMycsICdkMycsICdlMycsICdmMycsICdnMycsICdoMycsXG4gICAgJ2EyJywgJ2IyJywgJ2MyJywgJ2QyJywgJ2UyJywgJ2YyJywgJ2cyJywgJ2gyJyxcbiAgICAnYTEnLCAnYjEnLCAnYzEnLCAnZDEnLCAnZTEnLCAnZjEnLCAnZzEnLCAnaDEnXG5dO1xuY29uc3QgQklUUyA9IHtcbiAgICBOT1JNQUw6IDEsXG4gICAgQ0FQVFVSRTogMixcbiAgICBCSUdfUEFXTjogNCxcbiAgICBFUF9DQVBUVVJFOiA4LFxuICAgIFBST01PVElPTjogMTYsXG4gICAgS1NJREVfQ0FTVExFOiAzMixcbiAgICBRU0lERV9DQVNUTEU6IDY0LFxuICAgIE5VTExfTU9WRTogMTI4LFxufTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuLy8gdGhlc2UgYXJlIHJlcXVpcmVkLCBhY2NvcmRpbmcgdG8gc3BlY1xuY29uc3QgU0VWRU5fVEFHX1JPU1RFUiA9IHtcbiAgICBFdmVudDogJz8nLFxuICAgIFNpdGU6ICc/JyxcbiAgICBEYXRlOiAnPz8/Py4/Py4/PycsXG4gICAgUm91bmQ6ICc/JyxcbiAgICBXaGl0ZTogJz8nLFxuICAgIEJsYWNrOiAnPycsXG4gICAgUmVzdWx0OiAnKicsXG59O1xuLyoqXG4gKiBUaGVzZSBudWxscyBhcmUgcGxhY2Vob2xkZXJzIHRvIGZpeCB0aGUgb3JkZXIgb2YgdGFncyAoYXMgdGhleSBhcHBlYXIgaW4gUEdOIHNwZWMpOyBudWxsIHZhbHVlcyB3aWxsIGJlXG4gKiBlbGltaW5hdGVkIGluIGdldEhlYWRlcnMoKVxuICovXG5jb25zdCBTVVBMRU1FTlRBTF9UQUdTID0ge1xuICAgIFdoaXRlVGl0bGU6IG51bGwsXG4gICAgQmxhY2tUaXRsZTogbnVsbCxcbiAgICBXaGl0ZUVsbzogbnVsbCxcbiAgICBCbGFja0VsbzogbnVsbCxcbiAgICBXaGl0ZVVTQ0Y6IG51bGwsXG4gICAgQmxhY2tVU0NGOiBudWxsLFxuICAgIFdoaXRlTkE6IG51bGwsXG4gICAgQmxhY2tOQTogbnVsbCxcbiAgICBXaGl0ZVR5cGU6IG51bGwsXG4gICAgQmxhY2tUeXBlOiBudWxsLFxuICAgIEV2ZW50RGF0ZTogbnVsbCxcbiAgICBFdmVudFNwb25zb3I6IG51bGwsXG4gICAgU2VjdGlvbjogbnVsbCxcbiAgICBTdGFnZTogbnVsbCxcbiAgICBCb2FyZDogbnVsbCxcbiAgICBPcGVuaW5nOiBudWxsLFxuICAgIFZhcmlhdGlvbjogbnVsbCxcbiAgICBTdWJWYXJpYXRpb246IG51bGwsXG4gICAgRUNPOiBudWxsLFxuICAgIE5JQzogbnVsbCxcbiAgICBUaW1lOiBudWxsLFxuICAgIFVUQ1RpbWU6IG51bGwsXG4gICAgVVRDRGF0ZTogbnVsbCxcbiAgICBUaW1lQ29udHJvbDogbnVsbCxcbiAgICBTZXRVcDogbnVsbCxcbiAgICBGRU46IG51bGwsXG4gICAgVGVybWluYXRpb246IG51bGwsXG4gICAgQW5ub3RhdG9yOiBudWxsLFxuICAgIE1vZGU6IG51bGwsXG4gICAgUGx5Q291bnQ6IG51bGwsXG59O1xuY29uc3QgSEVBREVSX1RFTVBMQVRFID0ge1xuICAgIC4uLlNFVkVOX1RBR19ST1NURVIsXG4gICAgLi4uU1VQTEVNRU5UQUxfVEFHUyxcbn07XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuLypcbiAqIE5PVEVTIEFCT1VUIDB4ODggTU9WRSBHRU5FUkFUSU9OIEFMR09SSVRITVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vamhseXdhL2NoZXNzLmpzL2lzc3Vlcy8yMzBcbiAqXG4gKiBBIGxvdCBvZiBwZW9wbGUgYXJlIGNvbmZ1c2VkIHdoZW4gdGhleSBmaXJzdCBzZWUgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gKiBvZiBjaGVzcy5qcy4gSXQgdXNlcyB0aGUgMHg4OCBNb3ZlIEdlbmVyYXRpb24gQWxnb3JpdGhtIHdoaWNoIGludGVybmFsbHlcbiAqIHN0b3JlcyB0aGUgYm9hcmQgYXMgYW4gOHgxNiBhcnJheS4gVGhpcyBpcyBwdXJlbHkgZm9yIGVmZmljaWVuY3kgYnV0IGhhcyBhXG4gKiBjb3VwbGUgb2YgaW50ZXJlc3RpbmcgYmVuZWZpdHM6XG4gKlxuICogMS4gMHg4OCBvZmZlcnMgYSB2ZXJ5IGluZXhwZW5zaXZlIFwib2ZmIHRoZSBib2FyZFwiIGNoZWNrLiBCaXR3aXNlIEFORCAoJikgYW55XG4gKiAgICBzcXVhcmUgd2l0aCAweDg4LCBpZiB0aGUgcmVzdWx0IGlzIG5vbi16ZXJvIHRoZW4gdGhlIHNxdWFyZSBpcyBvZmYgdGhlXG4gKiAgICBib2FyZC4gRm9yIGV4YW1wbGUsIGFzc3VtaW5nIGEga25pZ2h0IHNxdWFyZSBBOCAoMCBpbiAweDg4IG5vdGF0aW9uKSxcbiAqICAgIHRoZXJlIGFyZSA4IHBvc3NpYmxlIGRpcmVjdGlvbnMgaW4gd2hpY2ggdGhlIGtuaWdodCBjYW4gbW92ZS4gVGhlc2VcbiAqICAgIGRpcmVjdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoZSA4eDE2IGJvYXJkIGFuZCBhcmUgc3RvcmVkIGluIHRoZVxuICogICAgUElFQ0VfT0ZGU0VUUyBtYXAuIE9uZSBwb3NzaWJsZSBtb3ZlIGlzIEE4IC0gMTggKHVwIG9uZSBzcXVhcmUsIGFuZCB0d29cbiAqICAgIHNxdWFyZXMgdG8gdGhlIGxlZnQgLSB3aGljaCBpcyBvZmYgdGhlIGJvYXJkKS4gMCAtIDE4ID0gLTE4ICYgMHg4OCA9IDB4ODhcbiAqICAgIChiZWNhdXNlIG9mIHR3by1jb21wbGVtZW50IHJlcHJlc2VudGF0aW9uIG9mIC0xOCkuIFRoZSBub24temVybyByZXN1bHRcbiAqICAgIG1lYW5zIHRoZSBzcXVhcmUgaXMgb2ZmIHRoZSBib2FyZCBhbmQgdGhlIG1vdmUgaXMgaWxsZWdhbC4gVGFrZSB0aGVcbiAqICAgIG9wcG9zaXRlIG1vdmUgKGZyb20gQTggdG8gQzcpLCAwICsgMTggPSAxOCAmIDB4ODggPSAwLiBBIHJlc3VsdCBvZiB6ZXJvXG4gKiAgICBtZWFucyB0aGUgc3F1YXJlIGlzIG9uIHRoZSBib2FyZC5cbiAqXG4gKiAyLiBUaGUgcmVsYXRpdmUgZGlzdGFuY2UgKG9yIGRpZmZlcmVuY2UpIGJldHdlZW4gdHdvIHNxdWFyZXMgb24gYSA4eDE2IGJvYXJkXG4gKiAgICBpcyB1bmlxdWUgYW5kIGNhbiBiZSB1c2VkIHRvIGluZXhwZW5zaXZlbHkgZGV0ZXJtaW5lIGlmIGEgcGllY2Ugb24gYVxuICogICAgc3F1YXJlIGNhbiBhdHRhY2sgYW55IG90aGVyIGFyYml0cmFyeSBzcXVhcmUuIEZvciBleGFtcGxlLCBsZXQncyBzZWUgaWYgYVxuICogICAgcGF3biBvbiBFNyBjYW4gYXR0YWNrIEUyLiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIEU3ICgyMCkgLSBFMiAoMTAwKSBpc1xuICogICAgLTgwLiBXZSBhZGQgMTE5IHRvIG1ha2UgdGhlIEFUVEFDS1MgYXJyYXkgaW5kZXggbm9uLW5lZ2F0aXZlIChiZWNhdXNlIHRoZVxuICogICAgd29yc3QgY2FzZSBkaWZmZXJlbmNlIGlzIEE4IC0gSDEgPSAtMTE5KS4gVGhlIEFUVEFDS1MgYXJyYXkgY29udGFpbnMgYVxuICogICAgYml0bWFzayBvZiBwaWVjZXMgdGhhdCBjYW4gYXR0YWNrIGZyb20gdGhhdCBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uLlxuICogICAgQVRUQUNLU1stODAgKyAxMTk9MzldIGdpdmVzIHVzIDI0IG9yIDBiMTEwMDAgaW4gYmluYXJ5LiBMb29rIGF0IHRoZVxuICogICAgUElFQ0VfTUFTS1MgbWFwIHRvIGRldGVybWluZSB0aGUgbWFzayBmb3IgYSBnaXZlbiBwaWVjZSB0eXBlLiBJbiBvdXIgcGF3blxuICogICAgZXhhbXBsZSwgd2Ugd291bGQgY2hlY2sgdG8gc2VlIGlmIDI0ICYgMHgxIGlzIG5vbi16ZXJvLCB3aGljaCBpdCBpc1xuICogICAgbm90LiBTbywgbmF0dXJhbGx5LCBhIHBhd24gb24gRTcgY2FuJ3QgYXR0YWNrIGEgcGllY2Ugb24gRTIuIEhvd2V2ZXIsIGFcbiAqICAgIHJvb2sgY2FuIHNpbmNlIDI0ICYgMHg4IGlzIG5vbi16ZXJvLiBUaGUgb25seSB0aGluZyBsZWZ0IHRvIGNoZWNrIGlzIHRoYXRcbiAqICAgIHRoZXJlIGFyZSBubyBibG9ja2luZyBwaWVjZXMgYmV0d2VlbiBFNyBhbmQgRTIuIFRoYXQncyB3aGVyZSB0aGUgUkFZU1xuICogICAgYXJyYXkgY29tZXMgaW4uIEl0IHByb3ZpZGVzIGFuIG9mZnNldCAoaW4gdGhpcyBjYXNlIDE2KSB0byBhZGQgdG8gRTcgKDIwKVxuICogICAgdG8gY2hlY2sgZm9yIGJsb2NraW5nIHBpZWNlcy4gRTcgKDIwKSArIDE2ID0gRTYgKDM2KSArIDE2ID0gRTUgKDUyKSBldGMuXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5jb25zdCBPeDg4ID0ge1xuICAgIGE4OiAwLCBiODogMSwgYzg6IDIsIGQ4OiAzLCBlODogNCwgZjg6IDUsIGc4OiA2LCBoODogNyxcbiAgICBhNzogMTYsIGI3OiAxNywgYzc6IDE4LCBkNzogMTksIGU3OiAyMCwgZjc6IDIxLCBnNzogMjIsIGg3OiAyMyxcbiAgICBhNjogMzIsIGI2OiAzMywgYzY6IDM0LCBkNjogMzUsIGU2OiAzNiwgZjY6IDM3LCBnNjogMzgsIGg2OiAzOSxcbiAgICBhNTogNDgsIGI1OiA0OSwgYzU6IDUwLCBkNTogNTEsIGU1OiA1MiwgZjU6IDUzLCBnNTogNTQsIGg1OiA1NSxcbiAgICBhNDogNjQsIGI0OiA2NSwgYzQ6IDY2LCBkNDogNjcsIGU0OiA2OCwgZjQ6IDY5LCBnNDogNzAsIGg0OiA3MSxcbiAgICBhMzogODAsIGIzOiA4MSwgYzM6IDgyLCBkMzogODMsIGUzOiA4NCwgZjM6IDg1LCBnMzogODYsIGgzOiA4NyxcbiAgICBhMjogOTYsIGIyOiA5NywgYzI6IDk4LCBkMjogOTksIGUyOiAxMDAsIGYyOiAxMDEsIGcyOiAxMDIsIGgyOiAxMDMsXG4gICAgYTE6IDExMiwgYjE6IDExMywgYzE6IDExNCwgZDE6IDExNSwgZTE6IDExNiwgZjE6IDExNywgZzE6IDExOCwgaDE6IDExOVxufTtcbmNvbnN0IFBBV05fT0ZGU0VUUyA9IHtcbiAgICBiOiBbMTYsIDMyLCAxNywgMTVdLFxuICAgIHc6IFstMTYsIC0zMiwgLTE3LCAtMTVdLFxufTtcbmNvbnN0IFBJRUNFX09GRlNFVFMgPSB7XG4gICAgbjogWy0xOCwgLTMzLCAtMzEsIC0xNCwgMTgsIDMzLCAzMSwgMTRdLFxuICAgIGI6IFstMTcsIC0xNSwgMTcsIDE1XSxcbiAgICByOiBbLTE2LCAxLCAxNiwgLTFdLFxuICAgIHE6IFstMTcsIC0xNiwgLTE1LCAxLCAxNywgMTYsIDE1LCAtMV0sXG4gICAgazogWy0xNywgLTE2LCAtMTUsIDEsIDE3LCAxNiwgMTUsIC0xXSxcbn07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEFUVEFDS1MgPSBbXG4gICAgMjAsIDAsIDAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAwLCAwLCAyMCwgMCxcbiAgICAwLCAyMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDIwLCAwLCAwLFxuICAgIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMjAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAyMCwgMCwgMCwgMjQsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDIwLCAyLCAyNCwgMiwgMjAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMiwgNTMsIDU2LCA1MywgMiwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCA1NiwgMCwgNTYsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMiwgNTMsIDU2LCA1MywgMiwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAyMCwgMiwgMjQsIDIsIDIwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDIwLCAwLCAwLCAyNCwgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMjAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAyMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLFxuICAgIDAsIDIwLCAwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsXG4gICAgMjAsIDAsIDAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAwLCAwLCAyMFxuXTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgUkFZUyA9IFtcbiAgICAxNywgMCwgMCwgMCwgMCwgMCwgMCwgMTYsIDAsIDAsIDAsIDAsIDAsIDAsIDE1LCAwLFxuICAgIDAsIDE3LCAwLCAwLCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMCwgMCwgMTUsIDAsIDAsXG4gICAgMCwgMCwgMTcsIDAsIDAsIDAsIDAsIDE2LCAwLCAwLCAwLCAwLCAxNSwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAxNywgMCwgMCwgMCwgMTYsIDAsIDAsIDAsIDE1LCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDE3LCAwLCAwLCAxNiwgMCwgMCwgMTUsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMTcsIDAsIDE2LCAwLCAxNSwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAwLCAxNywgMTYsIDE1LCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIC0xNSwgLTE2LCAtMTcsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgLTE1LCAwLCAtMTYsIDAsIC0xNywgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAtMTUsIDAsIDAsIC0xNiwgMCwgMCwgLTE3LCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIC0xNSwgMCwgMCwgMCwgLTE2LCAwLCAwLCAwLCAtMTcsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgLTE1LCAwLCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIDAsIC0xNywgMCwgMCwgMCxcbiAgICAwLCAtMTUsIDAsIDAsIDAsIDAsIDAsIC0xNiwgMCwgMCwgMCwgMCwgMCwgLTE3LCAwLCAwLFxuICAgIC0xNSwgMCwgMCwgMCwgMCwgMCwgMCwgLTE2LCAwLCAwLCAwLCAwLCAwLCAwLCAtMTdcbl07XG5jb25zdCBQSUVDRV9NQVNLUyA9IHsgcDogMHgxLCBuOiAweDIsIGI6IDB4NCwgcjogMHg4LCBxOiAweDEwLCBrOiAweDIwIH07XG5jb25zdCBTWU1CT0xTID0gJ3BuYnJxa1BOQlJRSyc7XG5jb25zdCBQUk9NT1RJT05TID0gW0tOSUdIVCwgQklTSE9QLCBST09LLCBRVUVFTl07XG5jb25zdCBSQU5LXzEgPSA3O1xuY29uc3QgUkFOS18yID0gNjtcbi8qXG4gKiBjb25zdCBSQU5LXzMgPSA1XG4gKiBjb25zdCBSQU5LXzQgPSA0XG4gKiBjb25zdCBSQU5LXzUgPSAzXG4gKiBjb25zdCBSQU5LXzYgPSAyXG4gKi9cbmNvbnN0IFJBTktfNyA9IDE7XG5jb25zdCBSQU5LXzggPSAwO1xuY29uc3QgU0lERVMgPSB7XG4gICAgW0tJTkddOiBCSVRTLktTSURFX0NBU1RMRSxcbiAgICBbUVVFRU5dOiBCSVRTLlFTSURFX0NBU1RMRSxcbn07XG5jb25zdCBST09LUyA9IHtcbiAgICB3OiBbXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4LmExLCBmbGFnOiBCSVRTLlFTSURFX0NBU1RMRSB9LFxuICAgICAgICB7IHNxdWFyZTogT3g4OC5oMSwgZmxhZzogQklUUy5LU0lERV9DQVNUTEUgfSxcbiAgICBdLFxuICAgIGI6IFtcbiAgICAgICAgeyBzcXVhcmU6IE94ODguYTgsIGZsYWc6IEJJVFMuUVNJREVfQ0FTVExFIH0sXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4Lmg4LCBmbGFnOiBCSVRTLktTSURFX0NBU1RMRSB9LFxuICAgIF0sXG59O1xuY29uc3QgU0VDT05EX1JBTksgPSB7IGI6IFJBTktfNywgdzogUkFOS18yIH07XG5jb25zdCBTQU5fTlVMTE1PVkUgPSAnLS0nO1xuLy8gRXh0cmFjdHMgdGhlIHplcm8tYmFzZWQgcmFuayBvZiBhbiAweDg4IHNxdWFyZS5cbmZ1bmN0aW9uIHJhbmsoc3F1YXJlKSB7XG4gICAgcmV0dXJuIHNxdWFyZSA+PiA0O1xufVxuLy8gRXh0cmFjdHMgdGhlIHplcm8tYmFzZWQgZmlsZSBvZiBhbiAweDg4IHNxdWFyZS5cbmZ1bmN0aW9uIGZpbGUoc3F1YXJlKSB7XG4gICAgcmV0dXJuIHNxdWFyZSAmIDB4Zjtcbn1cbmZ1bmN0aW9uIGlzRGlnaXQoYykge1xuICAgIHJldHVybiAnMDEyMzQ1Njc4OScuaW5kZXhPZihjKSAhPT0gLTE7XG59XG4vLyBDb252ZXJ0cyBhIDB4ODggc3F1YXJlIHRvIGFsZ2VicmFpYyBub3RhdGlvbi5cbmZ1bmN0aW9uIGFsZ2VicmFpYyhzcXVhcmUpIHtcbiAgICBjb25zdCBmID0gZmlsZShzcXVhcmUpO1xuICAgIGNvbnN0IHIgPSByYW5rKHNxdWFyZSk7XG4gICAgcmV0dXJuICgnYWJjZGVmZ2gnLnN1YnN0cmluZyhmLCBmICsgMSkgK1xuICAgICAgICAnODc2NTQzMjEnLnN1YnN0cmluZyhyLCByICsgMSkpO1xufVxuZnVuY3Rpb24gc3dhcENvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yID09PSBXSElURSA/IEJMQUNLIDogV0hJVEU7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUZlbihmZW4pIHtcbiAgICAvLyAxc3QgY3JpdGVyaW9uOiA2IHNwYWNlLXNlcGVyYXRlZCBmaWVsZHM/XG4gICAgY29uc3QgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IG11c3QgY29udGFpbiBzaXggc3BhY2UtZGVsaW1pdGVkIGZpZWxkcycsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDJuZCBjcml0ZXJpb246IG1vdmUgbnVtYmVyIGZpZWxkIGlzIGEgaW50ZWdlciB2YWx1ZSA+IDA/XG4gICAgY29uc3QgbW92ZU51bWJlciA9IHBhcnNlSW50KHRva2Vuc1s1XSwgMTApO1xuICAgIGlmIChpc05hTihtb3ZlTnVtYmVyKSB8fCBtb3ZlTnVtYmVyIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IG1vdmUgbnVtYmVyIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gM3JkIGNyaXRlcmlvbjogaGFsZiBtb3ZlIGNvdW50ZXIgaXMgYW4gaW50ZWdlciA+PSAwP1xuICAgIGNvbnN0IGhhbGZNb3ZlcyA9IHBhcnNlSW50KHRva2Vuc1s0XSwgMTApO1xuICAgIGlmIChpc05hTihoYWxmTW92ZXMpIHx8IGhhbGZNb3ZlcyA8IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IGhhbGYgbW92ZSBjb3VudGVyIG51bWJlciBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyA0dGggY3JpdGVyaW9uOiA0dGggZmllbGQgaXMgYSB2YWxpZCBlLnAuLXN0cmluZz9cbiAgICBpZiAoIS9eKC18W2FiY2RlZmdoXVszNl0pJC8udGVzdCh0b2tlbnNbM10pKSB7XG4gICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIEZFTjogZW4tcGFzc2FudCBzcXVhcmUgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gNXRoIGNyaXRlcmlvbjogM3RoIGZpZWxkIGlzIGEgdmFsaWQgY2FzdGxlLXN0cmluZz9cbiAgICBpZiAoL1tea0txUS1dLy50ZXN0KHRva2Vuc1syXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBjYXN0bGluZyBhdmFpbGFiaWxpdHkgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gNnRoIGNyaXRlcmlvbjogMm5kIGZpZWxkIGlzIFwid1wiICh3aGl0ZSkgb3IgXCJiXCIgKGJsYWNrKT9cbiAgICBpZiAoIS9eKHd8YikkLy50ZXN0KHRva2Vuc1sxXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBzaWRlLXRvLW1vdmUgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gN3RoIGNyaXRlcmlvbjogMXN0IGZpZWxkIGNvbnRhaW5zIDggcm93cz9cbiAgICBjb25zdCByb3dzID0gdG9rZW5zWzBdLnNwbGl0KCcvJyk7XG4gICAgaWYgKHJvd3MubGVuZ3RoICE9PSA4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogXCJJbnZhbGlkIEZFTjogcGllY2UgZGF0YSBkb2VzIG5vdCBjb250YWluIDggJy8nLWRlbGltaXRlZCByb3dzXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDh0aCBjcml0ZXJpb246IGV2ZXJ5IHJvdyBpcyB2YWxpZD9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHJpZ2h0IHN1bSBvZiBmaWVsZHMgQU5EIG5vdCB0d28gbnVtYmVycyBpbiBzdWNjZXNzaW9uXG4gICAgICAgIGxldCBzdW1GaWVsZHMgPSAwO1xuICAgICAgICBsZXQgcHJldmlvdXNXYXNOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3dzW2ldLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAoaXNEaWdpdChyb3dzW2ldW2tdKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1dhc051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogcGllY2UgZGF0YSBpcyBpbnZhbGlkIChjb25zZWN1dGl2ZSBudW1iZXIpJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtRmllbGRzICs9IHBhcnNlSW50KHJvd3NbaV1ba10sIDEwKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1dhc051bWJlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIS9eW3BybmJxa1BSTkJRS10kLy50ZXN0KHJvd3NbaV1ba10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKGludmFsaWQgcGllY2UpJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtRmllbGRzICs9IDE7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNXYXNOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VtRmllbGRzICE9PSA4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKHRvbyBtYW55IHNxdWFyZXMgaW4gcmFuayknLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyA5dGggY3JpdGVyaW9uOiBpcyBlbi1wYXNzYW50IHNxdWFyZSBsZWdhbD9cbiAgICBpZiAoKHRva2Vuc1szXVsxXSA9PSAnMycgJiYgdG9rZW5zWzFdID09ICd3JykgfHxcbiAgICAgICAgKHRva2Vuc1szXVsxXSA9PSAnNicgJiYgdG9rZW5zWzFdID09ICdiJykpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBpbGxlZ2FsIGVuLXBhc3NhbnQgc3F1YXJlJyB9O1xuICAgIH1cbiAgICAvLyAxMHRoIGNyaXRlcmlvbjogZG9lcyBjaGVzcyBwb3NpdGlvbiBjb250YWluIGV4YWN0IHR3byBraW5ncz9cbiAgICBjb25zdCBraW5ncyA9IFtcbiAgICAgICAgeyBjb2xvcjogJ3doaXRlJywgcmVnZXg6IC9LL2cgfSxcbiAgICAgICAgeyBjb2xvcjogJ2JsYWNrJywgcmVnZXg6IC9rL2cgfSxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgeyBjb2xvciwgcmVnZXggfSBvZiBraW5ncykge1xuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QodG9rZW5zWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogYEludmFsaWQgRkVOOiBtaXNzaW5nICR7Y29sb3J9IGtpbmdgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0b2tlbnNbMF0ubWF0Y2gocmVnZXgpIHx8IFtdKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBgSW52YWxpZCBGRU46IHRvbyBtYW55ICR7Y29sb3J9IGtpbmdzYCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDExdGggY3JpdGVyaW9uOiBhcmUgYW55IHBhd25zIG9uIHRoZSBmaXJzdCBvciBlaWdodGggcm93cz9cbiAgICBpZiAoQXJyYXkuZnJvbShyb3dzWzBdICsgcm93c1s3XSkuc29tZSgoY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpID09PSAnUCcpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBzb21lIHBhd25zIGFyZSBvbiB0aGUgZWRnZSByb3dzJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb2s6IHRydWUgfTtcbn1cbi8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBhbWJpZ3VvdXMgbW92ZXNcbmZ1bmN0aW9uIGdldERpc2FtYmlndWF0b3IobW92ZSwgbW92ZXMpIHtcbiAgICBjb25zdCBmcm9tID0gbW92ZS5mcm9tO1xuICAgIGNvbnN0IHRvID0gbW92ZS50bztcbiAgICBjb25zdCBwaWVjZSA9IG1vdmUucGllY2U7XG4gICAgbGV0IGFtYmlndWl0aWVzID0gMDtcbiAgICBsZXQgc2FtZVJhbmsgPSAwO1xuICAgIGxldCBzYW1lRmlsZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFtYmlnRnJvbSA9IG1vdmVzW2ldLmZyb207XG4gICAgICAgIGNvbnN0IGFtYmlnVG8gPSBtb3Zlc1tpXS50bztcbiAgICAgICAgY29uc3QgYW1iaWdQaWVjZSA9IG1vdmVzW2ldLnBpZWNlO1xuICAgICAgICAvKlxuICAgICAgICAgKiBpZiBhIG1vdmUgb2YgdGhlIHNhbWUgcGllY2UgdHlwZSBlbmRzIG9uIHRoZSBzYW1lIHRvIHNxdWFyZSwgd2UnbGwgbmVlZFxuICAgICAgICAgKiB0byBhZGQgYSBkaXNhbWJpZ3VhdG9yIHRvIHRoZSBhbGdlYnJhaWMgbm90YXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGlmIChwaWVjZSA9PT0gYW1iaWdQaWVjZSAmJiBmcm9tICE9PSBhbWJpZ0Zyb20gJiYgdG8gPT09IGFtYmlnVG8pIHtcbiAgICAgICAgICAgIGFtYmlndWl0aWVzKys7XG4gICAgICAgICAgICBpZiAocmFuayhmcm9tKSA9PT0gcmFuayhhbWJpZ0Zyb20pKSB7XG4gICAgICAgICAgICAgICAgc2FtZVJhbmsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxlKGZyb20pID09PSBmaWxlKGFtYmlnRnJvbSkpIHtcbiAgICAgICAgICAgICAgICBzYW1lRmlsZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbWJpZ3VpdGllcyA+IDApIHtcbiAgICAgICAgaWYgKHNhbWVSYW5rID4gMCAmJiBzYW1lRmlsZSA+IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpZiB0aGVyZSBleGlzdHMgYSBzaW1pbGFyIG1vdmluZyBwaWVjZSBvbiB0aGUgc2FtZSByYW5rIGFuZCBmaWxlIGFzXG4gICAgICAgICAgICAgKiB0aGUgbW92ZSBpbiBxdWVzdGlvbiwgdXNlIHRoZSBzcXVhcmUgYXMgdGhlIGRpc2FtYmlndWF0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGFsZ2VicmFpYyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzYW1lRmlsZSA+IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpZiB0aGUgbW92aW5nIHBpZWNlIHJlc3RzIG9uIHRoZSBzYW1lIGZpbGUsIHVzZSB0aGUgcmFuayBzeW1ib2wgYXMgdGhlXG4gICAgICAgICAgICAgKiBkaXNhbWJpZ3VhdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSkuY2hhckF0KDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZWxzZSB1c2UgdGhlIGZpbGUgc3ltYm9sXG4gICAgICAgICAgICByZXR1cm4gYWxnZWJyYWljKGZyb20pLmNoYXJBdCgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBhZGRNb3ZlKG1vdmVzLCBjb2xvciwgZnJvbSwgdG8sIHBpZWNlLCBjYXB0dXJlZCA9IHVuZGVmaW5lZCwgZmxhZ3MgPSBCSVRTLk5PUk1BTCkge1xuICAgIGNvbnN0IHIgPSByYW5rKHRvKTtcbiAgICBpZiAocGllY2UgPT09IFBBV04gJiYgKHIgPT09IFJBTktfMSB8fCByID09PSBSQU5LXzgpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUFJPTU9USU9OUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvbW90aW9uID0gUFJPTU9USU9OU1tpXTtcbiAgICAgICAgICAgIG1vdmVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgcGllY2UsXG4gICAgICAgICAgICAgICAgY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgcHJvbW90aW9uLFxuICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncyB8IEJJVFMuUFJPTU9USU9OLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1vdmVzLnB1c2goe1xuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBwaWVjZSxcbiAgICAgICAgICAgIGNhcHR1cmVkLFxuICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluZmVyUGllY2VUeXBlKHNhbikge1xuICAgIGxldCBwaWVjZVR5cGUgPSBzYW4uY2hhckF0KDApO1xuICAgIGlmIChwaWVjZVR5cGUgPj0gJ2EnICYmIHBpZWNlVHlwZSA8PSAnaCcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNhbi5tYXRjaCgvW2EtaF1cXGQuKlthLWhdXFxkLyk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQQVdOO1xuICAgIH1cbiAgICBwaWVjZVR5cGUgPSBwaWVjZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocGllY2VUeXBlID09PSAnbycpIHtcbiAgICAgICAgcmV0dXJuIEtJTkc7XG4gICAgfVxuICAgIHJldHVybiBwaWVjZVR5cGU7XG59XG4vLyBwYXJzZXMgYWxsIG9mIHRoZSBkZWNvcmF0b3JzIG91dCBvZiBhIFNBTiBzdHJpbmdcbmZ1bmN0aW9uIHN0cmlwcGVkU2FuKG1vdmUpIHtcbiAgICByZXR1cm4gbW92ZS5yZXBsYWNlKC89LywgJycpLnJlcGxhY2UoL1srI10/Wz8hXSokLywgJycpO1xufVxuY2xhc3MgQ2hlc3Mge1xuICAgIF9ib2FyZCA9IG5ldyBBcnJheSgxMjgpO1xuICAgIF90dXJuID0gV0hJVEU7XG4gICAgX2hlYWRlciA9IHt9O1xuICAgIF9raW5ncyA9IHsgdzogRU1QVFksIGI6IEVNUFRZIH07XG4gICAgX2VwU3F1YXJlID0gLTE7XG4gICAgX2hhbGZNb3ZlcyA9IDA7XG4gICAgX21vdmVOdW1iZXIgPSAwO1xuICAgIF9oaXN0b3J5ID0gW107XG4gICAgX2NvbW1lbnRzID0ge307XG4gICAgX2Nhc3RsaW5nID0geyB3OiAwLCBiOiAwIH07XG4gICAgX2hhc2ggPSAwbjtcbiAgICAvLyB0cmFja3MgbnVtYmVyIG9mIHRpbWVzIGEgcG9zaXRpb24gaGFzIGJlZW4gc2VlbiBmb3IgcmVwZXRpdGlvbiBjaGVja2luZ1xuICAgIF9wb3NpdGlvbkNvdW50ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0cnVjdG9yKGZlbiA9IERFRkFVTFRfUE9TSVRJT04sIHsgc2tpcFZhbGlkYXRpb24gPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5sb2FkKGZlbiwgeyBza2lwVmFsaWRhdGlvbiB9KTtcbiAgICB9XG4gICAgY2xlYXIoeyBwcmVzZXJ2ZUhlYWRlcnMgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5fYm9hcmQgPSBuZXcgQXJyYXkoMTI4KTtcbiAgICAgICAgdGhpcy5fa2luZ3MgPSB7IHc6IEVNUFRZLCBiOiBFTVBUWSB9O1xuICAgICAgICB0aGlzLl90dXJuID0gV0hJVEU7XG4gICAgICAgIHRoaXMuX2Nhc3RsaW5nID0geyB3OiAwLCBiOiAwIH07XG4gICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IDA7XG4gICAgICAgIHRoaXMuX21vdmVOdW1iZXIgPSAxO1xuICAgICAgICB0aGlzLl9oaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMuX2NvbW1lbnRzID0ge307XG4gICAgICAgIHRoaXMuX2hlYWRlciA9IHByZXNlcnZlSGVhZGVycyA/IHRoaXMuX2hlYWRlciA6IHsgLi4uSEVBREVSX1RFTVBMQVRFIH07XG4gICAgICAgIHRoaXMuX2hhc2ggPSB0aGlzLl9jb21wdXRlSGFzaCgpO1xuICAgICAgICB0aGlzLl9wb3NpdGlvbkNvdW50ID0gbmV3IE1hcCgpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBEZWxldGUgdGhlIFNldFVwIGFuZCBGRU4gaGVhZGVycyAoaWYgcHJlc2VydmVkKSwgdGhlIGJvYXJkIGlzIGVtcHR5IGFuZFxuICAgICAgICAgKiB0aGVzZSBoZWFkZXJzIGRvbid0IG1ha2Ugc2Vuc2UgaW4gdGhpcyBzdGF0ZS4gVGhleSdsbCBnZXQgYWRkZWQgbGF0ZXJcbiAgICAgICAgICogdmlhIC5sb2FkKCkgb3IgLnB1dCgpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9oZWFkZXJbJ1NldFVwJ10gPSBudWxsO1xuICAgICAgICB0aGlzLl9oZWFkZXJbJ0ZFTiddID0gbnVsbDtcbiAgICB9XG4gICAgbG9hZChmZW4sIHsgc2tpcFZhbGlkYXRpb24gPSBmYWxzZSwgcHJlc2VydmVIZWFkZXJzID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIGxldCB0b2tlbnMgPSBmZW4uc3BsaXQoL1xccysvKTtcbiAgICAgICAgLy8gYXBwZW5kIGNvbW1vbmx5IG9taXR0ZWQgZmVuIHRva2Vuc1xuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+PSAyICYmIHRva2Vucy5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50cyA9IFsnLScsICctJywgJzAnLCAnMSddO1xuICAgICAgICAgICAgZmVuID0gdG9rZW5zLmNvbmNhdChhZGp1c3RtZW50cy5zbGljZSgtKDYgLSB0b2tlbnMubGVuZ3RoKSkpLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMgPSBmZW4uc3BsaXQoL1xccysvKTtcbiAgICAgICAgaWYgKCFza2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgeyBvaywgZXJyb3IgfSA9IHZhbGlkYXRlRmVuKGZlbik7XG4gICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRva2Vuc1swXTtcbiAgICAgICAgbGV0IHNxdWFyZSA9IDA7XG4gICAgICAgIHRoaXMuY2xlYXIoeyBwcmVzZXJ2ZUhlYWRlcnMgfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gcG9zaXRpb24uY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKHBpZWNlID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBzcXVhcmUgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGlnaXQocGllY2UpKSB7XG4gICAgICAgICAgICAgICAgc3F1YXJlICs9IHBhcnNlSW50KHBpZWNlLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHBpZWNlIDwgJ2EnID8gV0hJVEUgOiBCTEFDSztcbiAgICAgICAgICAgICAgICB0aGlzLl9wdXQoeyB0eXBlOiBwaWVjZS50b0xvd2VyQ2FzZSgpLCBjb2xvciB9LCBhbGdlYnJhaWMoc3F1YXJlKSk7XG4gICAgICAgICAgICAgICAgc3F1YXJlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHVybiA9IHRva2Vuc1sxXTtcbiAgICAgICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdLJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyB8PSBCSVRTLktTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ1EnKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy53IHw9IEJJVFMuUVNJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZignaycpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgfD0gQklUUy5LU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdxJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcuYiB8PSBCSVRTLlFTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IHRva2Vuc1szXSA9PT0gJy0nID8gRU1QVFkgOiBPeDg4W3Rva2Vuc1szXV07XG4gICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IHBhcnNlSW50KHRva2Vuc1s0XSwgMTApO1xuICAgICAgICB0aGlzLl9tb3ZlTnVtYmVyID0gcGFyc2VJbnQodG9rZW5zWzVdLCAxMCk7XG4gICAgICAgIHRoaXMuX2hhc2ggPSB0aGlzLl9jb21wdXRlSGFzaCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVTZXR1cChmZW4pO1xuICAgICAgICB0aGlzLl9pbmNQb3NpdGlvbkNvdW50KCk7XG4gICAgfVxuICAgIGZlbih7IGZvcmNlRW5wYXNzYW50U3F1YXJlID0gZmFsc2UsIH0gPSB7fSkge1xuICAgICAgICBsZXQgZW1wdHkgPSAwO1xuICAgICAgICBsZXQgZmVuID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmZW4gKz0gZW1wdHk7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2xvciwgdHlwZTogcGllY2UgfSA9IHRoaXMuX2JvYXJkW2ldO1xuICAgICAgICAgICAgICAgIGZlbiArPSBjb2xvciA9PT0gV0hJVEUgPyBwaWVjZS50b1VwcGVyQ2FzZSgpIDogcGllY2UudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtcHR5Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW1wdHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlbiArPSBlbXB0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IE94ODguaDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVuICs9ICcvJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW1wdHkgPSAwO1xuICAgICAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FzdGxpbmcgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW1dISVRFXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBjYXN0bGluZyArPSAnSyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW1dISVRFXSAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBjYXN0bGluZyArPSAnUSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW0JMQUNLXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBjYXN0bGluZyArPSAnayc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW0JMQUNLXSAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBjYXN0bGluZyArPSAncSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gd2UgaGF2ZSBhbiBlbXB0eSBjYXN0bGluZyBmbGFnP1xuICAgICAgICBjYXN0bGluZyA9IGNhc3RsaW5nIHx8ICctJztcbiAgICAgICAgbGV0IGVwU3F1YXJlID0gJy0nO1xuICAgICAgICAvKlxuICAgICAgICAgKiBvbmx5IHByaW50IHRoZSBlcCBzcXVhcmUgaWYgZW4gcGFzc2FudCBpcyBhIHZhbGlkIG1vdmUgKHBhd24gaXMgcHJlc2VudFxuICAgICAgICAgKiBhbmQgZXAgY2FwdHVyZSBpcyBub3QgcGlubmVkKVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuX2VwU3F1YXJlICE9PSBFTVBUWSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlRW5wYXNzYW50U3F1YXJlKSB7XG4gICAgICAgICAgICAgICAgZXBTcXVhcmUgPSBhbGdlYnJhaWModGhpcy5fZXBTcXVhcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmlnUGF3blNxdWFyZSA9IHRoaXMuX2VwU3F1YXJlICsgKHRoaXMuX3R1cm4gPT09IFdISVRFID8gMTYgOiAtMTYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZXMgPSBbYmlnUGF3blNxdWFyZSArIDEsIGJpZ1Bhd25TcXVhcmUgLSAxXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNxdWFyZSBvZiBzcXVhcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIHRoZSBzcXVhcmUgb2ZmIHRoZSBib2FyZD9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNxdWFyZSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fdHVybjtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgdGhlcmUgYSBwYXduIHRoYXQgY2FuIGNhcHR1cmUgdGhlIGVwU3F1YXJlP1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbc3F1YXJlXT8uY29sb3IgPT09IGNvbG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy50eXBlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGF3biBtYWtlcyBhbiBlcCBjYXB0dXJlLCBkb2VzIGl0IGxlYXZlIGl0cyBraW5nIGluIGNoZWNrP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5fZXBTcXVhcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGllY2U6IFBBV04sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZWQ6IFBBV04sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IEJJVFMuRVBfQ0FQVFVSRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNMZWdhbCA9ICF0aGlzLl9pc0tpbmdBdHRhY2tlZChjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZXAgaXMgbGVnYWwsIGJyZWFrIGFuZCBzZXQgdGhlIGVwIHNxdWFyZSBpbiB0aGUgRkVOIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVnYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcFNxdWFyZSA9IGFsZ2VicmFpYyh0aGlzLl9lcFNxdWFyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZlbixcbiAgICAgICAgICAgIHRoaXMuX3R1cm4sXG4gICAgICAgICAgICBjYXN0bGluZyxcbiAgICAgICAgICAgIGVwU3F1YXJlLFxuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzLFxuICAgICAgICAgICAgdGhpcy5fbW92ZU51bWJlcixcbiAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgfVxuICAgIF9waWVjZUtleShpKSB7XG4gICAgICAgIGlmICghdGhpcy5fYm9hcmRbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiAwbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNvbG9yLCB0eXBlIH0gPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgY29uc3QgY29sb3JJbmRleCA9IHtcbiAgICAgICAgICAgIHc6IDAsXG4gICAgICAgICAgICBiOiAxLFxuICAgICAgICB9W2NvbG9yXTtcbiAgICAgICAgY29uc3QgdHlwZUluZGV4ID0ge1xuICAgICAgICAgICAgcDogMCxcbiAgICAgICAgICAgIG46IDEsXG4gICAgICAgICAgICBiOiAyLFxuICAgICAgICAgICAgcjogMyxcbiAgICAgICAgICAgIHE6IDQsXG4gICAgICAgICAgICBrOiA1LFxuICAgICAgICB9W3R5cGVdO1xuICAgICAgICByZXR1cm4gUElFQ0VfS0VZU1tjb2xvckluZGV4XVt0eXBlSW5kZXhdW2ldO1xuICAgIH1cbiAgICBfZXBLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcFNxdWFyZSA9PT0gRU1QVFkgPyAwbiA6IEVQX0tFWVNbdGhpcy5fZXBTcXVhcmUgJiA3XTtcbiAgICB9XG4gICAgX2Nhc3RsaW5nS2V5KCkge1xuICAgICAgICBjb25zdCBpbmRleCA9ICh0aGlzLl9jYXN0bGluZy53ID4+IDUpIHwgKHRoaXMuX2Nhc3RsaW5nLmIgPj4gMyk7XG4gICAgICAgIHJldHVybiBDQVNUTElOR19LRVlTW2luZGV4XTtcbiAgICB9XG4gICAgX2NvbXB1dGVIYXNoKCkge1xuICAgICAgICBsZXQgaGFzaCA9IDBuO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGRpZCB3ZSBydW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGJvYXJkXG4gICAgICAgICAgICBpZiAoaSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBpICs9IDc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbaV0pIHtcbiAgICAgICAgICAgICAgICBoYXNoIF49IHRoaXMuX3BpZWNlS2V5KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhhc2ggXj0gdGhpcy5fZXBLZXkoKTtcbiAgICAgICAgaGFzaCBePSB0aGlzLl9jYXN0bGluZ0tleSgpO1xuICAgICAgICBpZiAodGhpcy5fdHVybiA9PT0gJ2InKSB7XG4gICAgICAgICAgICBoYXNoIF49IFNJREVfS0VZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgICAvKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBpbml0aWFsIGJvYXJkIHNldHVwIGlzIGNoYW5nZWQgd2l0aCBwdXQoKSBvciByZW1vdmUoKS5cbiAgICAgKiBtb2RpZmllcyB0aGUgU2V0VXAgYW5kIEZFTiBwcm9wZXJ0aWVzIG9mIHRoZSBoZWFkZXIgb2JqZWN0LiBJZiB0aGUgRkVOXG4gICAgICogaXMgZXF1YWwgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb24sIHRoZSBTZXRVcCBhbmQgRkVOIGFyZSBkZWxldGVkIHRoZSBzZXR1cFxuICAgICAqIGlzIG9ubHkgdXBkYXRlZCBpZiBoaXN0b3J5Lmxlbmd0aCBpcyB6ZXJvLCBpZSBtb3ZlcyBoYXZlbid0IGJlZW4gbWFkZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlU2V0dXAoZmVuKSB7XG4gICAgICAgIGlmICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChmZW4gIT09IERFRkFVTFRfUE9TSVRJT04pIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnU2V0VXAnXSA9ICcxJztcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnRkVOJ10gPSBmZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJbJ1NldFVwJ10gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyWydGRU4nXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubG9hZChERUZBVUxUX1BPU0lUSU9OKTtcbiAgICB9XG4gICAgZ2V0KHNxdWFyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9hcmRbT3g4OFtzcXVhcmVdXTtcbiAgICB9XG4gICAgZmluZFBpZWNlKHBpZWNlKSB7XG4gICAgICAgIGNvbnN0IHNxdWFyZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IE94ODguYTg7IGkgPD0gT3g4OC5oMTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBkaWQgd2UgcnVuIG9mZiB0aGUgZW5kIG9mIHRoZSBib2FyZFxuICAgICAgICAgICAgaWYgKGkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaSArPSA3O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgZW1wdHkgc3F1YXJlIG9yIHdyb25nIGNvbG9yXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2ldIHx8IHRoaXMuX2JvYXJkW2ldPy5jb2xvciAhPT0gcGllY2UuY29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHNxdWFyZSBjb250YWlucyB0aGUgcmVxdWVzdGVkIHBpZWNlXG4gICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbaV0uY29sb3IgPT09IHBpZWNlLmNvbG9yICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbaV0udHlwZSA9PT0gcGllY2UudHlwZSkge1xuICAgICAgICAgICAgICAgIHNxdWFyZXMucHVzaChhbGdlYnJhaWMoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcXVhcmVzO1xuICAgIH1cbiAgICBwdXQoeyB0eXBlLCBjb2xvciB9LCBzcXVhcmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3B1dCh7IHR5cGUsIGNvbG9yIH0sIHNxdWFyZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNhc3RsaW5nUmlnaHRzKCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVFblBhc3NhbnRTcXVhcmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNldHVwKHRoaXMuZmVuKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfc2V0KHNxLCBwaWVjZSkge1xuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX3BpZWNlS2V5KHNxKTtcbiAgICAgICAgdGhpcy5fYm9hcmRbc3FdID0gcGllY2U7XG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fcGllY2VLZXkoc3EpO1xuICAgIH1cbiAgICBfcHV0KHsgdHlwZSwgY29sb3IgfSwgc3F1YXJlKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBwaWVjZVxuICAgICAgICBpZiAoU1lNQk9MUy5pbmRleE9mKHR5cGUudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgZm9yIHZhbGlkIHNxdWFyZVxuICAgICAgICBpZiAoIShzcXVhcmUgaW4gT3g4OCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcSA9IE94ODhbc3F1YXJlXTtcbiAgICAgICAgLy8gZG9uJ3QgbGV0IHRoZSB1c2VyIHBsYWNlIG1vcmUgdGhhbiBvbmUga2luZ1xuICAgICAgICBpZiAodHlwZSA9PSBLSU5HICYmXG4gICAgICAgICAgICAhKHRoaXMuX2tpbmdzW2NvbG9yXSA9PSBFTVBUWSB8fCB0aGlzLl9raW5nc1tjb2xvcl0gPT0gc3EpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFBpZWNlT25TcXVhcmUgPSB0aGlzLl9ib2FyZFtzcV07XG4gICAgICAgIC8vIGlmIG9uZSBvZiB0aGUga2luZ3Mgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgcGllY2UgZnJvbSBhcmdzLCBzZXQgdGhlIGBfa2luZ3NgIHJlc3BlY3RpdmUgZW50cnkgdG8gYEVNUFRZYFxuICAgICAgICBpZiAoY3VycmVudFBpZWNlT25TcXVhcmUgJiYgY3VycmVudFBpZWNlT25TcXVhcmUudHlwZSA9PT0gS0lORykge1xuICAgICAgICAgICAgdGhpcy5fa2luZ3NbY3VycmVudFBpZWNlT25TcXVhcmUuY29sb3JdID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0KHNxLCB7IHR5cGU6IHR5cGUsIGNvbG9yOiBjb2xvciB9KTtcbiAgICAgICAgaWYgKHR5cGUgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW2NvbG9yXSA9IHNxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfY2xlYXIoc3EpIHtcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9waWVjZUtleShzcSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFtzcV07XG4gICAgfVxuICAgIHJlbW92ZShzcXVhcmUpIHtcbiAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLmdldChzcXVhcmUpO1xuICAgICAgICB0aGlzLl9jbGVhcihPeDg4W3NxdWFyZV0pO1xuICAgICAgICBpZiAocGllY2UgJiYgcGllY2UudHlwZSA9PT0gS0lORykge1xuICAgICAgICAgICAgdGhpcy5fa2luZ3NbcGllY2UuY29sb3JdID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FzdGxpbmdSaWdodHMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRW5QYXNzYW50U3F1YXJlKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNldHVwKHRoaXMuZmVuKCkpO1xuICAgICAgICByZXR1cm4gcGllY2U7XG4gICAgfVxuICAgIF91cGRhdGVDYXN0bGluZ1JpZ2h0cygpIHtcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9jYXN0bGluZ0tleSgpO1xuICAgICAgICBjb25zdCB3aGl0ZUtpbmdJblBsYWNlID0gdGhpcy5fYm9hcmRbT3g4OC5lMV0/LnR5cGUgPT09IEtJTkcgJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguZTFdPy5jb2xvciA9PT0gV0hJVEU7XG4gICAgICAgIGNvbnN0IGJsYWNrS2luZ0luUGxhY2UgPSB0aGlzLl9ib2FyZFtPeDg4LmU4XT8udHlwZSA9PT0gS0lORyAmJlxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5lOF0/LmNvbG9yID09PSBCTEFDSztcbiAgICAgICAgaWYgKCF3aGl0ZUtpbmdJblBsYWNlIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmExXT8udHlwZSAhPT0gUk9PSyB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hMV0/LmNvbG9yICE9PSBXSElURSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyAmPSAtNjU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3aGl0ZUtpbmdJblBsYWNlIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmgxXT8udHlwZSAhPT0gUk9PSyB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oMV0/LmNvbG9yICE9PSBXSElURSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyAmPSAtMzM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFibGFja0tpbmdJblBsYWNlIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmE4XT8udHlwZSAhPT0gUk9PSyB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hOF0/LmNvbG9yICE9PSBCTEFDSykge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcuYiAmPSAtNjU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFibGFja0tpbmdJblBsYWNlIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4Lmg4XT8udHlwZSAhPT0gUk9PSyB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oOF0/LmNvbG9yICE9PSBCTEFDSykge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcuYiAmPSAtMzM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9jYXN0bGluZ0tleSgpO1xuICAgIH1cbiAgICBfdXBkYXRlRW5QYXNzYW50U3F1YXJlKCkge1xuICAgICAgICBpZiAodGhpcy5fZXBTcXVhcmUgPT09IEVNUFRZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRTcXVhcmUgPSB0aGlzLl9lcFNxdWFyZSArICh0aGlzLl90dXJuID09PSBXSElURSA/IC0xNiA6IDE2KTtcbiAgICAgICAgY29uc3QgY3VycmVudFNxdWFyZSA9IHRoaXMuX2VwU3F1YXJlICsgKHRoaXMuX3R1cm4gPT09IFdISVRFID8gMTYgOiAtMTYpO1xuICAgICAgICBjb25zdCBhdHRhY2tlcnMgPSBbY3VycmVudFNxdWFyZSArIDEsIGN1cnJlbnRTcXVhcmUgLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3N0YXJ0U3F1YXJlXSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbdGhpcy5fZXBTcXVhcmVdICE9PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtjdXJyZW50U3F1YXJlXT8uY29sb3IgIT09IHN3YXBDb2xvcih0aGlzLl90dXJuKSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbY3VycmVudFNxdWFyZV0/LnR5cGUgIT09IFBBV04pIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fZXBLZXkoKTtcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuQ2FwdHVyZSA9IChzcXVhcmUpID0+ICEoc3F1YXJlICYgMHg4OCkgJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW3NxdWFyZV0/LmNvbG9yID09PSB0aGlzLl90dXJuICYmXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy50eXBlID09PSBQQVdOO1xuICAgICAgICBpZiAoIWF0dGFja2Vycy5zb21lKGNhbkNhcHR1cmUpKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2VwS2V5KCk7XG4gICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IEVNUFRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hdHRhY2tlZChjb2xvciwgc3F1YXJlLCB2ZXJib3NlKSB7XG4gICAgICAgIGNvbnN0IGF0dGFja2VycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGRpZCB3ZSBydW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGJvYXJkXG4gICAgICAgICAgICBpZiAoaSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBpICs9IDc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBlbXB0eSBzcXVhcmUgb3Igd3JvbmcgY29sb3JcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2JvYXJkW2ldLmNvbG9yICE9PSBjb2xvcikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBpIC0gc3F1YXJlO1xuICAgICAgICAgICAgLy8gc2tpcCAtIHRvL2Zyb20gc3F1YXJlIGFyZSB0aGUgc2FtZVxuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZGlmZmVyZW5jZSArIDExOTtcbiAgICAgICAgICAgIGlmIChBVFRBQ0tTW2luZGV4XSAmIFBJRUNFX01BU0tTW3BpZWNlLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09IFBBV04pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkaWZmZXJlbmNlID4gMCAmJiBwaWVjZS5jb2xvciA9PT0gV0hJVEUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZGlmZmVyZW5jZSA8PSAwICYmIHBpZWNlLmNvbG9yID09PSBCTEFDSykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNrZXJzLnB1c2goYWxnZWJyYWljKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBpZWNlIGlzIGEga25pZ2h0IG9yIGEga2luZ1xuICAgICAgICAgICAgICAgIGlmIChwaWVjZS50eXBlID09PSAnbicgfHwgcGllY2UudHlwZSA9PT0gJ2snKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2tlcnMucHVzaChhbGdlYnJhaWMoaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gUkFZU1tpbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IGogPSBpICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGxldCBibG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGogIT09IHNxdWFyZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbal0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBqICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFibG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2tlcnMucHVzaChhbGdlYnJhaWMoaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhdHRhY2tlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNrZXJzKHNxdWFyZSwgYXR0YWNrZWRCeSkge1xuICAgICAgICBpZiAoIWF0dGFja2VkQnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2tlZCh0aGlzLl90dXJuLCBPeDg4W3NxdWFyZV0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKGF0dGFja2VkQnksIE94ODhbc3F1YXJlXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2lzS2luZ0F0dGFja2VkKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IHNxdWFyZSA9IHRoaXMuX2tpbmdzW2NvbG9yXTtcbiAgICAgICAgcmV0dXJuIHNxdWFyZSA9PT0gLTEgPyBmYWxzZSA6IHRoaXMuX2F0dGFja2VkKHN3YXBDb2xvcihjb2xvciksIHNxdWFyZSk7XG4gICAgfVxuICAgIGhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNoLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgaXNBdHRhY2tlZChzcXVhcmUsIGF0dGFja2VkQnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKGF0dGFja2VkQnksIE94ODhbc3F1YXJlXSk7XG4gICAgfVxuICAgIGlzQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0tpbmdBdHRhY2tlZCh0aGlzLl90dXJuKTtcbiAgICB9XG4gICAgaW5DaGVjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpO1xuICAgIH1cbiAgICBpc0NoZWNrbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpICYmIHRoaXMuX21vdmVzKCkubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpc1N0YWxlbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQ2hlY2soKSAmJiB0aGlzLl9tb3ZlcygpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogay5iLiB2cyBrLmIuIChvZiBvcHBvc2l0ZSBjb2xvcnMpIHdpdGggbWF0ZSBpbiAxOlxuICAgICAgICAgKiA4LzgvOC84LzFiNi84L0IxazUvSzcgYiAtIC0gMCAxXG4gICAgICAgICAqXG4gICAgICAgICAqIGsuYi4gdnMgay5uLiB3aXRoIG1hdGUgaW4gMTpcbiAgICAgICAgICogOC84LzgvOC8xbjYvOC9CNy9LMWs1IGIgLSAtIDIgMVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcGllY2VzID0ge1xuICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgIG46IDAsXG4gICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgcTogMCxcbiAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICBwOiAwLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBiaXNob3BzID0gW107XG4gICAgICAgIGxldCBudW1QaWVjZXMgPSAwO1xuICAgICAgICBsZXQgc3F1YXJlQ29sb3IgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIHNxdWFyZUNvbG9yID0gKHNxdWFyZUNvbG9yICsgMSkgJSAyO1xuICAgICAgICAgICAgaWYgKGkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaSArPSA3O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgICAgIGlmIChwaWVjZSkge1xuICAgICAgICAgICAgICAgIHBpZWNlc1twaWVjZS50eXBlXSA9IHBpZWNlLnR5cGUgaW4gcGllY2VzID8gcGllY2VzW3BpZWNlLnR5cGVdICsgMSA6IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09IEJJU0hPUCkge1xuICAgICAgICAgICAgICAgICAgICBiaXNob3BzLnB1c2goc3F1YXJlQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW1QaWVjZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBrIHZzLiBrXG4gICAgICAgIGlmIChudW1QaWVjZXMgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBrIHZzLiBrbiAuLi4uIG9yIC4uLi4gayB2cy4ga2JcbiAgICAgICAgbnVtUGllY2VzID09PSAzICYmXG4gICAgICAgICAgICAocGllY2VzW0JJU0hPUF0gPT09IDEgfHwgcGllY2VzW0tOSUdIVF0gPT09IDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1QaWVjZXMgPT09IHBpZWNlc1tCSVNIT1BdICsgMikge1xuICAgICAgICAgICAgLy8ga2IgdnMuIGtiIHdoZXJlIGFueSBudW1iZXIgb2YgYmlzaG9wcyBhcmUgYWxsIG9uIHRoZSBzYW1lIGNvbG9yXG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJpc2hvcHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bSArPSBiaXNob3BzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1bSA9PT0gMCB8fCBzdW0gPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNUaHJlZWZvbGRSZXBldGl0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UG9zaXRpb25Db3VudCh0aGlzLl9oYXNoKSA+PSAzO1xuICAgIH1cbiAgICBpc0RyYXdCeUZpZnR5TW92ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYWxmTW92ZXMgPj0gMTAwOyAvLyA1MCBtb3ZlcyBwZXIgc2lkZSA9IDEwMCBoYWxmIG1vdmVzXG4gICAgfVxuICAgIGlzRHJhdygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzRHJhd0J5RmlmdHlNb3ZlcygpIHx8XG4gICAgICAgICAgICB0aGlzLmlzU3RhbGVtYXRlKCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpIHx8XG4gICAgICAgICAgICB0aGlzLmlzVGhyZWVmb2xkUmVwZXRpdGlvbigpKTtcbiAgICB9XG4gICAgaXNHYW1lT3ZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVja21hdGUoKSB8fCB0aGlzLmlzRHJhdygpO1xuICAgIH1cbiAgICBtb3Zlcyh7IHZlcmJvc2UgPSBmYWxzZSwgc3F1YXJlID0gdW5kZWZpbmVkLCBwaWVjZSA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vdmVzID0gdGhpcy5fbW92ZXMoeyBzcXVhcmUsIHBpZWNlIH0pO1xuICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vdmVzLm1hcCgobW92ZSkgPT4gbmV3IE1vdmUodGhpcywgbW92ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1vdmVzLm1hcCgobW92ZSkgPT4gdGhpcy5fbW92ZVRvU2FuKG1vdmUsIG1vdmVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX21vdmVzKHsgbGVnYWwgPSB0cnVlLCBwaWVjZSA9IHVuZGVmaW5lZCwgc3F1YXJlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZm9yU3F1YXJlID0gc3F1YXJlID8gc3F1YXJlLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGZvclBpZWNlID0gcGllY2U/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IG1vdmVzID0gW107XG4gICAgICAgIGNvbnN0IHVzID0gdGhpcy5fdHVybjtcbiAgICAgICAgY29uc3QgdGhlbSA9IHN3YXBDb2xvcih1cyk7XG4gICAgICAgIGxldCBmaXJzdFNxdWFyZSA9IE94ODguYTg7XG4gICAgICAgIGxldCBsYXN0U3F1YXJlID0gT3g4OC5oMTtcbiAgICAgICAgbGV0IHNpbmdsZVNxdWFyZSA9IGZhbHNlO1xuICAgICAgICAvLyBhcmUgd2UgZ2VuZXJhdGluZyBtb3ZlcyBmb3IgYSBzaW5nbGUgc3F1YXJlP1xuICAgICAgICBpZiAoZm9yU3F1YXJlKSB7XG4gICAgICAgICAgICAvLyBpbGxlZ2FsIHNxdWFyZSwgcmV0dXJuIGVtcHR5IG1vdmVzXG4gICAgICAgICAgICBpZiAoIShmb3JTcXVhcmUgaW4gT3g4OCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXJzdFNxdWFyZSA9IGxhc3RTcXVhcmUgPSBPeDg4W2ZvclNxdWFyZV07XG4gICAgICAgICAgICAgICAgc2luZ2xlU3F1YXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBmcm9tID0gZmlyc3RTcXVhcmU7IGZyb20gPD0gbGFzdFNxdWFyZTsgZnJvbSsrKSB7XG4gICAgICAgICAgICAvLyBkaWQgd2UgcnVuIG9mZiB0aGUgZW5kIG9mIHRoZSBib2FyZFxuICAgICAgICAgICAgaWYgKGZyb20gJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgZnJvbSArPSA3O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW1wdHkgc3F1YXJlIG9yIG9wcG9uZW50LCBza2lwXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2Zyb21dIHx8IHRoaXMuX2JvYXJkW2Zyb21dLmNvbG9yID09PSB0aGVtKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHRoaXMuX2JvYXJkW2Zyb21dO1xuICAgICAgICAgICAgbGV0IHRvO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFBBV04pIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yUGllY2UgJiYgZm9yUGllY2UgIT09IHR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBzcXVhcmUsIG5vbi1jYXB0dXJpbmdcbiAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBQQVdOX09GRlNFVFNbdXNdWzBdO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbdG9dKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgUEFXTik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvdWJsZSBzcXVhcmVcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBmcm9tICsgUEFXTl9PRkZTRVRTW3VzXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFNFQ09ORF9SQU5LW3VzXSA9PT0gcmFuayhmcm9tKSAmJiAhdGhpcy5fYm9hcmRbdG9dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04sIHVuZGVmaW5lZCwgQklUUy5CSUdfUEFXTik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcGF3biBjYXB0dXJlc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAyOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gZnJvbSArIFBBV05fT0ZGU0VUU1t1c11bal07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0byAmIDB4ODgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3RvXT8uY29sb3IgPT09IHRoZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgUEFXTiwgdGhpcy5fYm9hcmRbdG9dLnR5cGUsIEJJVFMuQ0FQVFVSRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG8gPT09IHRoaXMuX2VwU3F1YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04sIFBBV04sIEJJVFMuRVBfQ0FQVFVSRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yUGllY2UgJiYgZm9yUGllY2UgIT09IHR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBsZW4gPSBQSUVDRV9PRkZTRVRTW3R5cGVdLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IFBJRUNFX09GRlNFVFNbdHlwZV1bal07XG4gICAgICAgICAgICAgICAgICAgIHRvID0gZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0byAmIDB4ODgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW3RvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvd24gY29sb3IsIHN0b3AgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFt0b10uY29sb3IgPT09IHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIHR5cGUsIHRoaXMuX2JvYXJkW3RvXS50eXBlLCBCSVRTLkNBUFRVUkUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLyogYnJlYWssIGlmIGtuaWdodCBvciBraW5nICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gS05JR0hUIHx8IHR5cGUgPT09IEtJTkcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogY2hlY2sgZm9yIGNhc3RsaW5nIGlmIHdlJ3JlOlxuICAgICAgICAgKiAgIGEpIGdlbmVyYXRpbmcgYWxsIG1vdmVzLCBvclxuICAgICAgICAgKiAgIGIpIGRvaW5nIHNpbmdsZSBzcXVhcmUgbW92ZSBnZW5lcmF0aW9uIG9uIHRoZSBraW5nJ3Mgc3F1YXJlXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZm9yUGllY2UgPT09IHVuZGVmaW5lZCB8fCBmb3JQaWVjZSA9PT0gS0lORykge1xuICAgICAgICAgICAgaWYgKCFzaW5nbGVTcXVhcmUgfHwgbGFzdFNxdWFyZSA9PT0gdGhpcy5fa2luZ3NbdXNdKSB7XG4gICAgICAgICAgICAgICAgLy8ga2luZy1zaWRlIGNhc3RsaW5nXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3VzXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IHRoaXMuX2tpbmdzW3VzXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IGNhc3RsaW5nRnJvbSArIDI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tICsgMV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9ib2FyZFtjYXN0bGluZ1RvXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIHRoaXMuX2tpbmdzW3VzXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ0Zyb20gKyAxKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIGNhc3RsaW5nVG8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgdGhpcy5fa2luZ3NbdXNdLCBjYXN0bGluZ1RvLCBLSU5HLCB1bmRlZmluZWQsIEJJVFMuS1NJREVfQ0FTVExFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBxdWVlbi1zaWRlIGNhc3RsaW5nXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3VzXSAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IHRoaXMuX2tpbmdzW3VzXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IGNhc3RsaW5nRnJvbSAtIDI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tIC0gMV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb20gLSAyXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSAtIDNdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgdGhpcy5fa2luZ3NbdXNdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIGNhc3RsaW5nRnJvbSAtIDEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdUbykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCB0aGlzLl9raW5nc1t1c10sIGNhc3RsaW5nVG8sIEtJTkcsIHVuZGVmaW5lZCwgQklUUy5RU0lERV9DQVNUTEUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIHJldHVybiBhbGwgcHNldWRvLWxlZ2FsIG1vdmVzICh0aGlzIGluY2x1ZGVzIG1vdmVzIHRoYXQgYWxsb3cgdGhlIGtpbmdcbiAgICAgICAgICogdG8gYmUgY2FwdHVyZWQpXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIWxlZ2FsIHx8IHRoaXMuX2tpbmdzW3VzXSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3ZlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBmaWx0ZXIgb3V0IGlsbGVnYWwgbW92ZXNcbiAgICAgICAgY29uc3QgbGVnYWxNb3ZlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmVzW2ldKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNLaW5nQXR0YWNrZWQodXMpKSB7XG4gICAgICAgICAgICAgICAgbGVnYWxNb3Zlcy5wdXNoKG1vdmVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZ2FsTW92ZXM7XG4gICAgfVxuICAgIG1vdmUobW92ZSwgeyBzdHJpY3QgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIG1vdmUgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB3aXRoIGluIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgICAgICpcbiAgICAgICAgICogLm1vdmUoJ054YjcnKSAgICAgICA8LSBhcmd1bWVudCBpcyBhIGNhc2Utc2Vuc2l0aXZlIFNBTiBzdHJpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogLm1vdmUoeyBmcm9tOiAnaDcnLCA8LSBhcmd1bWVudCBpcyBhIG1vdmUgb2JqZWN0XG4gICAgICAgICAqICAgICAgICAgdG8gOidoOCcsXG4gICAgICAgICAqICAgICAgICAgcHJvbW90aW9uOiAncScgfSlcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogQW4gb3B0aW9uYWwgc3RyaWN0IGFyZ3VtZW50IG1heSBiZSBzdXBwbGllZCB0byB0ZWxsIGNoZXNzLmpzIHRvXG4gICAgICAgICAqIHN0cmljdGx5IGZvbGxvdyB0aGUgU0FOIHNwZWNpZmljYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbW92ZU9iaiA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgbW92ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1vdmVPYmogPSB0aGlzLl9tb3ZlRnJvbVNhbihtb3ZlLCBzdHJpY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vdmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG1vdmVPYmogPSB0aGlzLl9tb3ZlRnJvbVNhbihTQU5fTlVMTE1PVkUsIHN0cmljdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vdmUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlcyA9IHRoaXMuX21vdmVzKCk7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBwcmV0dHkgbW92ZSBvYmplY3QgdG8gYW4gdWdseSBtb3ZlIG9iamVjdFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmUuZnJvbSA9PT0gYWxnZWJyYWljKG1vdmVzW2ldLmZyb20pICYmXG4gICAgICAgICAgICAgICAgICAgIG1vdmUudG8gPT09IGFsZ2VicmFpYyhtb3Zlc1tpXS50bykgJiZcbiAgICAgICAgICAgICAgICAgICAgKCEoJ3Byb21vdGlvbicgaW4gbW92ZXNbaV0pIHx8IG1vdmUucHJvbW90aW9uID09PSBtb3Zlc1tpXS5wcm9tb3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVPYmogPSBtb3Zlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZhaWxlZCB0byBmaW5kIG1vdmVcbiAgICAgICAgaWYgKCFtb3ZlT2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vdmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1vdmU6ICR7bW92ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb3ZlOiAke0pTT04uc3RyaW5naWZ5KG1vdmUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vZGlzYWxsb3cgbnVsbCBtb3ZlcyB3aGVuIGluIGNoZWNrXG4gICAgICAgIGlmICh0aGlzLmlzQ2hlY2soKSAmJiBtb3ZlT2JqLmZsYWdzICYgQklUUy5OVUxMX01PVkUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnVsbCBtb3ZlIG5vdCBhbGxvd2VkIHdoZW4gaW4gY2hlY2snKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBuZWVkIHRvIG1ha2UgYSBjb3B5IG9mIG1vdmUgYmVjYXVzZSB3ZSBjYW4ndCBnZW5lcmF0ZSBTQU4gYWZ0ZXIgdGhlIG1vdmVcbiAgICAgICAgICogaXMgbWFkZVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcHJldHR5TW92ZSA9IG5ldyBNb3ZlKHRoaXMsIG1vdmVPYmopO1xuICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlT2JqKTtcbiAgICAgICAgdGhpcy5faW5jUG9zaXRpb25Db3VudCgpO1xuICAgICAgICByZXR1cm4gcHJldHR5TW92ZTtcbiAgICB9XG4gICAgX3B1c2gobW92ZSkge1xuICAgICAgICB0aGlzLl9oaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgbW92ZSxcbiAgICAgICAgICAgIGtpbmdzOiB7IGI6IHRoaXMuX2tpbmdzLmIsIHc6IHRoaXMuX2tpbmdzLncgfSxcbiAgICAgICAgICAgIHR1cm46IHRoaXMuX3R1cm4sXG4gICAgICAgICAgICBjYXN0bGluZzogeyBiOiB0aGlzLl9jYXN0bGluZy5iLCB3OiB0aGlzLl9jYXN0bGluZy53IH0sXG4gICAgICAgICAgICBlcFNxdWFyZTogdGhpcy5fZXBTcXVhcmUsXG4gICAgICAgICAgICBoYWxmTW92ZXM6IHRoaXMuX2hhbGZNb3ZlcyxcbiAgICAgICAgICAgIG1vdmVOdW1iZXI6IHRoaXMuX21vdmVOdW1iZXIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbW92ZVBpZWNlKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fcGllY2VLZXkoZnJvbSk7XG4gICAgICAgIHRoaXMuX2JvYXJkW3RvXSA9IHRoaXMuX2JvYXJkW2Zyb21dO1xuICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbZnJvbV07XG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fcGllY2VLZXkodG8pO1xuICAgIH1cbiAgICBfbWFrZU1vdmUobW92ZSkge1xuICAgICAgICBjb25zdCB1cyA9IHRoaXMuX3R1cm47XG4gICAgICAgIGNvbnN0IHRoZW0gPSBzd2FwQ29sb3IodXMpO1xuICAgICAgICB0aGlzLl9wdXNoKG1vdmUpO1xuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuTlVMTF9NT1ZFKSB7XG4gICAgICAgICAgICBpZiAodXMgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZU51bWJlcisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzKys7XG4gICAgICAgICAgICB0aGlzLl90dXJuID0gdGhlbTtcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9lcEtleSgpO1xuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XG4gICAgICAgIGlmIChtb3ZlLmNhcHR1cmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX3BpZWNlS2V5KG1vdmUudG8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vdmVQaWVjZShtb3ZlLmZyb20sIG1vdmUudG8pO1xuICAgICAgICAvLyBpZiBlcCBjYXB0dXJlLCByZW1vdmUgdGhlIGNhcHR1cmVkIHBhd25cbiAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLkVQX0NBUFRVUkUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90dXJuID09PSBCTEFDSykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyKG1vdmUudG8gLSAxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhcihtb3ZlLnRvICsgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHBhd24gcHJvbW90aW9uLCByZXBsYWNlIHdpdGggbmV3IHBpZWNlXG4gICAgICAgIGlmIChtb3ZlLnByb21vdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXIobW92ZS50byk7XG4gICAgICAgICAgICB0aGlzLl9zZXQobW92ZS50bywgeyB0eXBlOiBtb3ZlLnByb21vdGlvbiwgY29sb3I6IHVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIG1vdmVkIHRoZSBraW5nXG4gICAgICAgIGlmICh0aGlzLl9ib2FyZFttb3ZlLnRvXS50eXBlID09PSBLSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl9raW5nc1t1c10gPSBtb3ZlLnRvO1xuICAgICAgICAgICAgLy8gaWYgd2UgY2FzdGxlZCwgbW92ZSB0aGUgcm9vayBuZXh0IHRvIHRoZSBraW5nXG4gICAgICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IG1vdmUudG8gLSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVQaWVjZShjYXN0bGluZ0Zyb20sIGNhc3RsaW5nVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW92ZS5mbGFncyAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gLSAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVQaWVjZShjYXN0bGluZ0Zyb20sIGNhc3RsaW5nVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmdcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3VzXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmcgaWYgd2UgbW92ZSBhIHJvb2tcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3VzXSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IFJPT0tTW3VzXS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlLmZyb20gPT09IFJPT0tTW3VzXVtpXS5zcXVhcmUgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdXNdICYgUk9PS1NbdXNdW2ldLmZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdXNdIF49IFJPT0tTW3VzXVtpXS5mbGFnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmcgaWYgd2UgY2FwdHVyZSBhIHJvb2tcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3RoZW1dKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gUk9PS1NbdGhlbV0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS50byA9PT0gUk9PS1NbdGhlbV1baV0uc3F1YXJlICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3RoZW1dICYgUk9PS1NbdGhlbV1baV0uZmxhZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t0aGVtXSBePSBST09LU1t0aGVtXVtpXS5mbGFnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9jYXN0bGluZ0tleSgpO1xuICAgICAgICAvLyBpZiBiaWcgcGF3biBtb3ZlLCB1cGRhdGUgdGhlIGVuIHBhc3NhbnQgc3F1YXJlXG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5CSUdfUEFXTikge1xuICAgICAgICAgICAgbGV0IGVwU3F1YXJlO1xuICAgICAgICAgICAgaWYgKHVzID09PSBCTEFDSykge1xuICAgICAgICAgICAgICAgIGVwU3F1YXJlID0gbW92ZS50byAtIDE2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXBTcXVhcmUgPSBtb3ZlLnRvICsgMTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKCEoKG1vdmUudG8gLSAxKSAmIDB4ODgpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50byAtIDFdPy50eXBlID09PSBQQVdOICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50byAtIDFdPy5jb2xvciA9PT0gdGhlbSkgfHxcbiAgICAgICAgICAgICAgICAoISgobW92ZS50byArIDEpICYgMHg4OCkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50byArIDFdPy50eXBlID09PSBQQVdOICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JvYXJkW21vdmUudG8gKyAxXT8uY29sb3IgPT09IHRoZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBlcFNxdWFyZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2VwS2V5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IEVNUFRZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCB0aGUgNTAgbW92ZSBjb3VudGVyIGlmIGEgcGF3biBpcyBtb3ZlZCBvciBhIHBpZWNlIGlzIGNhcHR1cmVkXG4gICAgICAgIGlmIChtb3ZlLnBpZWNlID09PSBQQVdOKSB7XG4gICAgICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vdmUuZmxhZ3MgJiAoQklUUy5DQVBUVVJFIHwgQklUUy5FUF9DQVBUVVJFKSkge1xuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cyA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuX21vdmVOdW1iZXIrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90dXJuID0gdGhlbTtcbiAgICAgICAgdGhpcy5faGFzaCBePSBTSURFX0tFWTtcbiAgICB9XG4gICAgdW5kbygpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuX2hhc2g7XG4gICAgICAgIGNvbnN0IG1vdmUgPSB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgICAgY29uc3QgcHJldHR5TW92ZSA9IG5ldyBNb3ZlKHRoaXMsIG1vdmUpO1xuICAgICAgICAgICAgdGhpcy5fZGVjUG9zaXRpb25Db3VudChoYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV0dHlNb3ZlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfdW5kb01vdmUoKSB7XG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuX2hpc3RvcnkucG9wKCk7XG4gICAgICAgIGlmIChvbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9lcEtleSgpO1xuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XG4gICAgICAgIGNvbnN0IG1vdmUgPSBvbGQubW92ZTtcbiAgICAgICAgdGhpcy5fa2luZ3MgPSBvbGQua2luZ3M7XG4gICAgICAgIHRoaXMuX3R1cm4gPSBvbGQudHVybjtcbiAgICAgICAgdGhpcy5fY2FzdGxpbmcgPSBvbGQuY2FzdGxpbmc7XG4gICAgICAgIHRoaXMuX2VwU3F1YXJlID0gb2xkLmVwU3F1YXJlO1xuICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSBvbGQuaGFsZk1vdmVzO1xuICAgICAgICB0aGlzLl9tb3ZlTnVtYmVyID0gb2xkLm1vdmVOdW1iZXI7XG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fZXBLZXkoKTtcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9jYXN0bGluZ0tleSgpO1xuICAgICAgICB0aGlzLl9oYXNoIF49IFNJREVfS0VZO1xuICAgICAgICBjb25zdCB1cyA9IHRoaXMuX3R1cm47XG4gICAgICAgIGNvbnN0IHRoZW0gPSBzd2FwQ29sb3IodXMpO1xuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuTlVMTF9NT1ZFKSB7XG4gICAgICAgICAgICByZXR1cm4gbW92ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb3ZlUGllY2UobW92ZS50bywgbW92ZS5mcm9tKTtcbiAgICAgICAgLy8gdG8gdW5kbyBhbnkgcHJvbW90aW9uc1xuICAgICAgICBpZiAobW92ZS5waWVjZSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXIobW92ZS5mcm9tKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChtb3ZlLmZyb20sIHsgdHlwZTogbW92ZS5waWVjZSwgY29sb3I6IHVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlLmNhcHR1cmVkKSB7XG4gICAgICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuRVBfQ0FQVFVSRSkge1xuICAgICAgICAgICAgICAgIC8vIGVuIHBhc3NhbnQgY2FwdHVyZVxuICAgICAgICAgICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAodXMgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbW92ZS50byAtIDE2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBtb3ZlLnRvICsgMTY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldChpbmRleCwgeyB0eXBlOiBQQVdOLCBjb2xvcjogdGhlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlZ3VsYXIgY2FwdHVyZVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldChtb3ZlLnRvLCB7IHR5cGU6IG1vdmUuY2FwdHVyZWQsIGNvbG9yOiB0aGVtIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuS1NJREVfQ0FTVExFIHwgQklUUy5RU0lERV9DQVNUTEUpKSB7XG4gICAgICAgICAgICBsZXQgY2FzdGxpbmdUbywgY2FzdGxpbmdGcm9tO1xuICAgICAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgICAgIGNhc3RsaW5nVG8gPSBtb3ZlLnRvICsgMTtcbiAgICAgICAgICAgICAgICBjYXN0bGluZ0Zyb20gPSBtb3ZlLnRvIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhc3RsaW5nVG8gPSBtb3ZlLnRvIC0gMjtcbiAgICAgICAgICAgICAgICBjYXN0bGluZ0Zyb20gPSBtb3ZlLnRvICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21vdmVQaWVjZShjYXN0bGluZ0Zyb20sIGNhc3RsaW5nVG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb3ZlO1xuICAgIH1cbiAgICBwZ24oeyBuZXdsaW5lID0gJ1xcbicsIG1heFdpZHRoID0gMCwgfSA9IHt9KSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIHVzaW5nIHRoZSBzcGVjaWZpY2F0aW9uIGZyb20gaHR0cDovL3d3dy5jaGVzc2NsdWIuY29tL2hlbHAvUEdOLXNwZWNcbiAgICAgICAgICogZXhhbXBsZSBmb3IgaHRtbCB1c2FnZTogLnBnbih7IG1heF93aWR0aDogNzIsIG5ld2xpbmVfY2hhcjogXCI8YnIgLz5cIiB9KVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBoZWFkZXJFeGlzdHMgPSBmYWxzZTtcbiAgICAgICAgLyogYWRkIHRoZSBQR04gaGVhZGVyIGluZm9ybWF0aW9uICovXG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9oZWFkZXIpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUT0RPOiBvcmRlciBvZiBlbnVtZXJhdGVkIHByb3BlcnRpZXMgaW4gaGVhZGVyIG9iamVjdCBpcyBub3RcbiAgICAgICAgICAgICAqIGd1YXJhbnRlZWQsIHNlZSBFQ01BLTI2MiBzcGVjIChzZWN0aW9uIDEyLjYuNClcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBCeSB1c2luZyBIRUFERVJfVEVNUExBVEUsIHRoZSBvcmRlciBvZiB0YWdzIHNob3VsZCBiZSBwcmVzZXJ2ZWQ7IHdlXG4gICAgICAgICAgICAgKiBkbyBoYXZlIHRvIGNoZWNrIGZvciBudWxsIHBsYWNlaG9sZGVycywgdGhvdWdoLCBhbmQgb21pdCB0aGVtXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclRhZyA9IHRoaXMuX2hlYWRlcltpXTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJUYWcpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYFske2l9IFwiJHt0aGlzLl9oZWFkZXJbaV19XCJdYCArIG5ld2xpbmUpO1xuICAgICAgICAgICAgaGVhZGVyRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyRXhpc3RzICYmIHRoaXMuX2hpc3RvcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBlbmRDb21tZW50ID0gKG1vdmVTdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxpbWl0ZXIgPSBtb3ZlU3RyaW5nLmxlbmd0aCA+IDAgPyAnICcgOiAnJztcbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nID0gYCR7bW92ZVN0cmluZ30ke2RlbGltaXRlcn17JHtjb21tZW50fX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vdmVTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHBvcCBhbGwgb2YgaGlzdG9yeSBvbnRvIHJldmVyc2VkX2hpc3RvcnlcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRIaXN0b3J5ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldmVyc2VkSGlzdG9yeS5wdXNoKHRoaXMuX3VuZG9Nb3ZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vdmVzID0gW107XG4gICAgICAgIGxldCBtb3ZlU3RyaW5nID0gJyc7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBvZiBhIGNvbW1lbnRlZCBzdGFydGluZyBwb3NpdGlvbiB3aXRoIG5vIG1vdmVzXG4gICAgICAgIGlmIChyZXZlcnNlZEhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKGFwcGVuZENvbW1lbnQoJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWlsZCB0aGUgbGlzdCBvZiBtb3Zlcy4gIGEgbW92ZV9zdHJpbmcgbG9va3MgbGlrZTogXCIzLiBlMyBlNlwiXG4gICAgICAgIHdoaWxlIChyZXZlcnNlZEhpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbW92ZVN0cmluZyA9IGFwcGVuZENvbW1lbnQobW92ZVN0cmluZyk7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgLy8gbWFrZSBUeXBlU2NyaXB0IHN0b3AgY29tcGxhaW5pbmcgYWJvdXQgbW92ZSBiZWluZyB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghbW92ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIHBvc2l0aW9uIHN0YXJ0ZWQgd2l0aCBibGFjayB0byBtb3ZlLCBzdGFydCBQR04gd2l0aCAjLiAuLi5cbiAgICAgICAgICAgIGlmICghdGhpcy5faGlzdG9yeS5sZW5ndGggJiYgbW92ZS5jb2xvciA9PT0gJ2InKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYCR7dGhpcy5fbW92ZU51bWJlcn0uIC4uLmA7XG4gICAgICAgICAgICAgICAgLy8gaXMgdGhlcmUgYSBjb21tZW50IHByZWNlZGluZyB0aGUgZmlyc3QgbW92ZT9cbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nID0gbW92ZVN0cmluZyA/IGAke21vdmVTdHJpbmd9ICR7cHJlZml4fWAgOiBwcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb3ZlLmNvbG9yID09PSAndycpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgZ2VuZXJhdGVkIG1vdmVfc3RyaW5nIGlmIHdlIGhhdmUgb25lXG4gICAgICAgICAgICAgICAgaWYgKG1vdmVTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVzLnB1c2gobW92ZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vdmVTdHJpbmcgPSB0aGlzLl9tb3ZlTnVtYmVyICsgJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW92ZVN0cmluZyA9XG4gICAgICAgICAgICAgICAgbW92ZVN0cmluZyArICcgJyArIHRoaXMuX21vdmVUb1Nhbihtb3ZlLCB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFyZSB0aGVyZSBhbnkgb3RoZXIgbGVmdG92ZXIgbW92ZXM/XG4gICAgICAgIGlmIChtb3ZlU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgbW92ZXMucHVzaChhcHBlbmRDb21tZW50KG1vdmVTdHJpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpcyB0aGVyZSBhIHJlc3VsdD8gKHRoZXJlIEFMV0FZUyBoYXMgdG8gYmUgYSByZXN1bHQgYWNjb3JkaW5nIHRvIHNwZWM7IHNlZSBTZXZlbiBUYWcgUm9zdGVyKVxuICAgICAgICBtb3Zlcy5wdXNoKHRoaXMuX2hlYWRlci5SZXN1bHQgfHwgJyonKTtcbiAgICAgICAgLypcbiAgICAgICAgICogaGlzdG9yeSBzaG91bGQgYmUgYmFjayB0byB3aGF0IGl0IHdhcyBiZWZvcmUgd2Ugc3RhcnRlZCBnZW5lcmF0aW5nIFBHTixcbiAgICAgICAgICogc28gam9pbiB0b2dldGhlciBtb3Zlc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG1heFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpICsgbW92ZXMuam9pbignICcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gKGphaCk6IGh1aD9cbiAgICAgICAgY29uc3Qgc3RyaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBOQjogdGhpcyBkb2VzIG5vdCBwcmVzZXJ2ZSBjb21tZW50IHdoaXRlc3BhY2UuXG4gICAgICAgIGNvbnN0IHdyYXBDb21tZW50ID0gZnVuY3Rpb24gKHdpZHRoLCBtb3ZlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIG1vdmUuc3BsaXQoJyAnKSkge1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCArIHRva2VuLmxlbmd0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHJpcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB3aWR0aCArPSB0b2tlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgICB3aWR0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmlwKCkpIHtcbiAgICAgICAgICAgICAgICB3aWR0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICB9O1xuICAgICAgICAvLyB3cmFwIHRoZSBQR04gb3V0cHV0IGF0IG1heF93aWR0aFxuICAgICAgICBsZXQgY3VycmVudFdpZHRoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb3Zlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCArIG1vdmVzW2ldLmxlbmd0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVzW2ldLmluY2x1ZGVzKCd7JykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFdpZHRoID0gd3JhcENvbW1lbnQoY3VycmVudFdpZHRoLCBtb3Zlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IG1vdmUgd2lsbCBwdXNoIHBhc3QgbWF4X3dpZHRoXG4gICAgICAgICAgICBpZiAoY3VycmVudFdpZHRoICsgbW92ZXNbaV0ubGVuZ3RoID4gbWF4V2lkdGggJiYgaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGVuZCB0aGUgbGluZSB3aXRoIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFdpZHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnICcpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXaWR0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobW92ZXNbaV0pO1xuICAgICAgICAgICAgY3VycmVudFdpZHRoICs9IG1vdmVzW2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYHNldEhlYWRlcmAgYW5kIGBnZXRIZWFkZXJzYCBpbnN0ZWFkLiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBudWxsIGhlYWRlciB0YWdzICh3aGljaCBpcyBub3Qgd2hhdCB5b3Ugd2FudClcbiAgICAgKi9cbiAgICBoZWFkZXIoLi4uYXJncykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZ3NbaSArIDFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWRlclthcmdzW2ldXSA9IGFyZ3NbaSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XG4gICAgfVxuICAgIC8vIFRPRE86IHZhbHVlIHZhbGlkYXRpb24gcGVyIHNwZWNcbiAgICBzZXRIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oZWFkZXJba2V5XSA9IHZhbHVlID8/IFNFVkVOX1RBR19ST1NURVJba2V5XSA/PyBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkZXJzKCk7XG4gICAgfVxuICAgIHJlbW92ZUhlYWRlcihrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9oZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcltrZXldID0gU0VWRU5fVEFHX1JPU1RFUltrZXldIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHJldHVybiBvbmx5IG5vbi1udWxsIGhlYWRlcnMgKG9taXQgcGxhY2VtYXJrZXIgbnVsbHMpXG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3Qgbm9uTnVsbEhlYWRlcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5faGVhZGVyKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbm9uTnVsbEhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub25OdWxsSGVhZGVycztcbiAgICB9XG4gICAgbG9hZFBnbihwZ24sIHsgc3RyaWN0ID0gZmFsc2UsIG5ld2xpbmVDaGFyID0gJ1xccj9cXG4nLCB9ID0ge30pIHtcbiAgICAgICAgLy8gSWYgbmV3bGluZUNoYXIgaXMgbm90IHRoZSBkZWZhdWx0LCByZXBsYWNlIGFsbCBpbnN0YW5jZXMgd2l0aCBcXG5cbiAgICAgICAgaWYgKG5ld2xpbmVDaGFyICE9PSAnXFxyP1xcbicpIHtcbiAgICAgICAgICAgIHBnbiA9IHBnbi5yZXBsYWNlKG5ldyBSZWdFeHAobmV3bGluZUNoYXIsICdnJyksICdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRQZ24gPSBwZWckcGFyc2UocGduKTtcbiAgICAgICAgLy8gUHV0IHRoZSBib2FyZCBpbiB0aGUgc3RhcnRpbmcgcG9zaXRpb25cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAvLyBwYXJzZSBQR04gaGVhZGVyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBwYXJzZWRQZ24uaGVhZGVycztcbiAgICAgICAgbGV0IGZlbiA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgdXNlciBpcyBpbmNsdWRpbmcgZmVuIChwb3NzaWJseSB3aXRoIHdyb25nIHRhZyBjYXNlKVxuICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSAnZmVuJykge1xuICAgICAgICAgICAgICAgIGZlbiA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiB0aGUgcGVybWlzc2l2ZSBwYXJzZXIgc2hvdWxkIGF0dGVtcHQgdG8gbG9hZCBhIGZlbiB0YWcsIGV2ZW4gaWYgaXQncyB0aGVcbiAgICAgICAgICogd3JvbmcgY2FzZSBhbmQgZG9lc24ndCBpbmNsdWRlIGEgY29ycmVzcG9uZGluZyBbU2V0VXAgXCIxXCJdIHRhZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoZmVuLCB7IHByZXNlcnZlSGVhZGVyczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBzdHJpY3QgcGFyc2VyIC0gbG9hZCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gaW5kaWNhdGVkIGJ5IFtTZXR1cCAnMSddXG4gICAgICAgICAgICAgKiBhbmQgW0ZFTiBwb3NpdGlvbl1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ1NldFVwJ10gPT09ICcxJykge1xuICAgICAgICAgICAgICAgIGlmICghKCdGRU4nIGluIGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQR046IEZFTiB0YWcgbXVzdCBiZSBzdXBwbGllZCB3aXRoIFNldFVwIHRhZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBjbGVhciB0aGUgaGVhZGVycyB3aGVuIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoaGVhZGVyc1snRkVOJ10sIHsgcHJlc2VydmVIZWFkZXJzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gcGFyc2VkUGduLnJvb3Q7XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5tb3ZlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW92ZSA9IHRoaXMuX21vdmVGcm9tU2FuKG5vZGUubW92ZSwgc3RyaWN0KTtcbiAgICAgICAgICAgICAgICBpZiAobW92ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb3ZlIGluIFBHTjogJHtub2RlLm1vdmV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5jUG9zaXRpb25Db3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldID0gbm9kZS5jb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUudmFyaWF0aW9uc1swXTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBQZXIgc2VjdGlvbiA4LjIuNiBvZiB0aGUgUEdOIHNwZWMsIHRoZSBSZXN1bHQgdGFnIHBhaXIgbXVzdCBtYXRjaCBtYXRjaFxuICAgICAgICAgKiB0aGUgdGVybWluYXRpb24gbWFya2VyLiBPbmx5IGRvIHRoaXMgd2hlbiBoZWFkZXJzIGFyZSBwcmVzZW50LCBidXQgdGhlXG4gICAgICAgICAqIHJlc3VsdCB0YWcgaXMgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VkUGduLnJlc3VsdDtcbiAgICAgICAgaWYgKHJlc3VsdCAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5faGVhZGVyKS5sZW5ndGggJiZcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnUmVzdWx0J10gIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXIoJ1Jlc3VsdCcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGEgbW92ZSBmcm9tIDB4ODggY29vcmRpbmF0ZXMgdG8gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uXG4gICAgICogKFNBTilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RyaWN0IFVzZSB0aGUgc3RyaWN0IFNBTiBwYXJzZXIuIEl0IHdpbGwgdGhyb3cgZXJyb3JzXG4gICAgICogb24gb3Zlcmx5IGRpc2FtYmlndWF0ZWQgbW92ZXMgKHNlZSBiZWxvdyk6XG4gICAgICpcbiAgICAgKiByMWJxa2Juci9wcHAycHBwLzJuNS8xQjFwUDMvNFAzLzgvUFBQUDJQUC9STkJRSzFOUiBiIEtRa3EgLSAyIDRcbiAgICAgKiA0LiAuLi4gTmdlNyBpcyBvdmVybHkgZGlzYW1iaWd1YXRlZCBiZWNhdXNlIHRoZSBrbmlnaHQgb24gYzYgaXMgcGlubmVkXG4gICAgICogNC4gLi4uIE5lNyBpcyB0ZWNobmljYWxseSB0aGUgdmFsaWQgU0FOXG4gICAgICovXG4gICAgX21vdmVUb1Nhbihtb3ZlLCBtb3Zlcykge1xuICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgIG91dHB1dCA9ICdPLU8nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgb3V0cHV0ID0gJ08tTy1PJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgQklUUy5OVUxMX01PVkUpIHtcbiAgICAgICAgICAgIHJldHVybiBTQU5fTlVMTE1PVkU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobW92ZS5waWVjZSAhPT0gUEFXTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FtYmlndWF0b3IgPSBnZXREaXNhbWJpZ3VhdG9yKG1vdmUsIG1vdmVzKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gbW92ZS5waWVjZS50b1VwcGVyQ2FzZSgpICsgZGlzYW1iaWd1YXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuQ0FQVFVSRSB8IEJJVFMuRVBfQ0FQVFVSRSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5waWVjZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUuZnJvbSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSAneCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUudG8pO1xuICAgICAgICAgICAgaWYgKG1vdmUucHJvbW90aW9uKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICc9JyArIG1vdmUucHJvbW90aW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzQ2hlY2soKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDaGVja21hdGUoKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnIyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJysnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgYSBtb3ZlIGZyb20gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uIChTQU4pIHRvIDB4ODggY29vcmRpbmF0ZXNcbiAgICBfbW92ZUZyb21TYW4obW92ZSwgc3RyaWN0ID0gZmFsc2UpIHtcbiAgICAgICAgLy8gc3RyaXAgb2ZmIGFueSBtb3ZlIGRlY29yYXRpb25zOiBlLmcgTmYzKz8hIGJlY29tZXMgTmYzXG4gICAgICAgIGxldCBjbGVhbk1vdmUgPSBzdHJpcHBlZFNhbihtb3ZlKTtcbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChjbGVhbk1vdmUgPT09ICcwLTAnKSB7XG4gICAgICAgICAgICAgICAgY2xlYW5Nb3ZlID0gJ08tTyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbGVhbk1vdmUgPT09ICcwLTAtMCcpIHtcbiAgICAgICAgICAgICAgICBjbGVhbk1vdmUgPSAnTy1PLU8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vZmlyc3QgaW1wbGVtZW50YXRpb24gb2YgbnVsbCB3aXRoIGEgZHVtbXkgbW92ZSAoYmxhY2sga2luZyBtb3ZlcyBmcm9tIGE4IHRvIGE4KSwgbWF5YmUgdGhpcyBjYW4gYmUgaW1wbGVtZW50ZWQgYmV0dGVyXG4gICAgICAgIGlmIChjbGVhbk1vdmUgPT0gU0FOX05VTExNT1ZFKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuX3R1cm4sXG4gICAgICAgICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICAgICAgICB0bzogMCxcbiAgICAgICAgICAgICAgICBwaWVjZTogJ2snLFxuICAgICAgICAgICAgICAgIGZsYWdzOiBCSVRTLk5VTExfTU9WRSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwaWVjZVR5cGUgPSBpbmZlclBpZWNlVHlwZShjbGVhbk1vdmUpO1xuICAgICAgICBsZXQgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiB0cnVlLCBwaWVjZTogcGllY2VUeXBlIH0pO1xuICAgICAgICAvLyBzdHJpY3QgcGFyc2VyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGNsZWFuTW92ZSA9PT0gc3RyaXBwZWRTYW4odGhpcy5fbW92ZVRvU2FuKG1vdmVzW2ldLCBtb3ZlcykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBzdHJpY3QgcGFyc2VyIGZhaWxlZFxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGllY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBtYXRjaGVzID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHRvID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcHJvbW90aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBwZXJtaXNzaXZlIChub24tc3RyaWN0KSBwYXJzZXIgYWxsb3dzIHRoZSB1c2VyIHRvIHBhcnNlXG4gICAgICAgICAqIG5vbi1zdGFuZGFyZCBjaGVzcyBub3RhdGlvbnMuIFRoaXMgcGFyc2VyIGlzIG9ubHkgcnVuIGFmdGVyIHRoZSBzdHJpY3RcbiAgICAgICAgICogU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uIChTQU4pIHBhcnNlciBoYXMgZmFpbGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHJ1bm5pbmcgdGhlIHBlcm1pc3NpdmUgcGFyc2VyLCB3ZSdsbCBydW4gYSByZWdleCB0byBncmFiIHRoZSBwaWVjZSwgdGhlXG4gICAgICAgICAqIHRvL2Zyb20gc3F1YXJlLCBhbmQgYW4gb3B0aW9uYWwgcHJvbW90aW9uIHBpZWNlLiBUaGlzIHJlZ2V4IHdpbGxcbiAgICAgICAgICogcGFyc2UgY29tbW9uIG5vbi1zdGFuZGFyZCBub3RhdGlvbiBsaWtlOiBQZTItZTQsIFJjMWM0LCBRZjN4ZjcsXG4gICAgICAgICAqIGY3ZjhxLCBiMWMzXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IFNvbWUgcG9zaXRpb25zIGFuZCBtb3ZlcyBtYXkgYmUgYW1iaWd1b3VzIHdoZW4gdXNpbmcgdGhlIHBlcm1pc3NpdmVcbiAgICAgICAgICogcGFyc2VyLiBGb3IgZXhhbXBsZSwgaW4gdGhpcyBwb3NpdGlvbjogNmsxLzgvOC9CNy84LzgvOC9CTjRLMSB3IC0gLSAwIDEsXG4gICAgICAgICAqIHRoZSBtb3ZlIGIxYzMgbWF5IGJlIGludGVycHJldGVkIGFzIE5jMyBvciBCMWMzIChhIGRpc2FtYmlndWF0ZWQgYmlzaG9wXG4gICAgICAgICAqIG1vdmUpLiBJbiB0aGVzZSBjYXNlcywgdGhlIHBlcm1pc3NpdmUgcGFyc2VyIHdpbGwgZGVmYXVsdCB0byB0aGUgbW9zdFxuICAgICAgICAgKiBiYXNpYyBpbnRlcnByZXRhdGlvbiAod2hpY2ggaXMgYjFjMyBwYXJzaW5nIHRvIE5jMykuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgb3Zlcmx5RGlzYW1iaWd1YXRlZCA9IGZhbHNlO1xuICAgICAgICBtYXRjaGVzID0gY2xlYW5Nb3ZlLm1hdGNoKC8oW3BuYnJxa1BOQlJRS10pPyhbYS1oXVsxLThdKXg/LT8oW2EtaF1bMS04XSkoW3FyYm5RUkJOXSk/Lyk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICBwaWVjZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICBmcm9tID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgIHRvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgIHByb21vdGlvbiA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIG92ZXJseURpc2FtYmlndWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRoZSBbYS1oXT9bMS04XT8gcG9ydGlvbiBvZiB0aGUgcmVnZXggYmVsb3cgaGFuZGxlcyBtb3ZlcyB0aGF0IG1heSBiZVxuICAgICAgICAgICAgICogb3Zlcmx5IGRpc2FtYmlndWF0ZWQgKGUuZy4gTmdlNyBpcyB1bm5lY2Vzc2FyeSBhbmQgbm9uLXN0YW5kYXJkIHdoZW5cbiAgICAgICAgICAgICAqIHRoZXJlIGlzIG9uZSBsZWdhbCBrbmlnaHQgbW92ZSB0byBlNykuIEluIHRoaXMgY2FzZSwgdGhlIHZhbHVlIG9mXG4gICAgICAgICAgICAgKiAnZnJvbScgdmFyaWFibGUgd2lsbCBiZSBhIHJhbmsgb3IgZmlsZSwgbm90IGEgc3F1YXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtYXRjaGVzID0gY2xlYW5Nb3ZlLm1hdGNoKC8oW3BuYnJxa1BOQlJRS10pPyhbYS1oXT9bMS04XT8peD8tPyhbYS1oXVsxLThdKShbcXJiblFSQk5dKT8vKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcGllY2UgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgICAgIGZyb20gPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgICAgIHRvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgICAgICBwcm9tb3Rpb24gPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJseURpc2FtYmlndWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwaWVjZVR5cGUgPSBpbmZlclBpZWNlVHlwZShjbGVhbk1vdmUpO1xuICAgICAgICBtb3ZlcyA9IHRoaXMuX21vdmVzKHtcbiAgICAgICAgICAgIGxlZ2FsOiB0cnVlLFxuICAgICAgICAgICAgcGllY2U6IHBpZWNlID8gcGllY2UgOiBwaWVjZVR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZyb20gc3F1YXJlLCBpdCBjb3VsZCBiZSBqdXN0ICd4JyBtaXNzaW5nIGZyb20gYSBjYXB0dXJlXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFuTW92ZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgc3RyaXBwZWRTYW4odGhpcy5fbW92ZVRvU2FuKG1vdmVzW2ldLCBtb3ZlcykpLnJlcGxhY2UoJ3gnLCAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoYW5kLWNvbXBhcmUgbW92ZSBwcm9wZXJ0aWVzIHdpdGggdGhlIHJlc3VsdHMgZnJvbSBvdXIgcGVybWlzc2l2ZSByZWdleFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKCFwaWVjZSB8fCBwaWVjZS50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnBpZWNlKSAmJlxuICAgICAgICAgICAgICAgIE94ODhbZnJvbV0gPT0gbW92ZXNbaV0uZnJvbSAmJlxuICAgICAgICAgICAgICAgIE94ODhbdG9dID09IG1vdmVzW2ldLnRvICYmXG4gICAgICAgICAgICAgICAgKCFwcm9tb3Rpb24gfHwgcHJvbW90aW9uLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucHJvbW90aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJseURpc2FtYmlndWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFNQRUNJQUwgQ0FTRTogd2UgcGFyc2VkIGEgbW92ZSBzdHJpbmcgdGhhdCBtYXkgaGF2ZSBhbiB1bm5lZWRlZFxuICAgICAgICAgICAgICAgICAqIHJhbmsvZmlsZSBkaXNhbWJpZ3VhdG9yIChlLmcuIE5nZTcpLiAgVGhlICdmcm9tJyB2YXJpYWJsZSB3aWxsXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3Qgc3F1YXJlID0gYWxnZWJyYWljKG1vdmVzW2ldLmZyb20pO1xuICAgICAgICAgICAgICAgIGlmICgoIXBpZWNlIHx8IHBpZWNlLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucGllY2UpICYmXG4gICAgICAgICAgICAgICAgICAgIE94ODhbdG9dID09IG1vdmVzW2ldLnRvICYmXG4gICAgICAgICAgICAgICAgICAgIChmcm9tID09IHNxdWFyZVswXSB8fCBmcm9tID09IHNxdWFyZVsxXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9tb3Rpb24gfHwgcHJvbW90aW9uLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucHJvbW90aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW92ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc2NpaSgpIHtcbiAgICAgICAgbGV0IHMgPSAnICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcXG4nO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGRpc3BsYXkgdGhlIHJhbmtcbiAgICAgICAgICAgIGlmIChmaWxlKGkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICcgKyAnODc2NTQzMjEnW3JhbmsoaSldICsgJyB8JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gdGhpcy5fYm9hcmRbaV0udHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuX2JvYXJkW2ldLmNvbG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IGNvbG9yID09PSBXSElURSA/IHBpZWNlLnRvVXBwZXJDYXNlKCkgOiBwaWVjZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHMgKz0gJyAnICsgc3ltYm9sICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyArPSAnIC4gJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSArIDEpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIHMgKz0gJ3xcXG4nO1xuICAgICAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzICs9ICcgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xcbic7XG4gICAgICAgIHMgKz0gJyAgICAgYSAgYiAgYyAgZCAgZSAgZiAgZyAgaCc7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBwZXJmdChkZXB0aCkge1xuICAgICAgICBjb25zdCBtb3ZlcyA9IHRoaXMuX21vdmVzKHsgbGVnYWw6IGZhbHNlIH0pO1xuICAgICAgICBsZXQgbm9kZXMgPSAwO1xuICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuX3R1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZXNbaV0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0tpbmdBdHRhY2tlZChjb2xvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggLSAxID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlcyArPSB0aGlzLnBlcmZ0KGRlcHRoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBzZXRUdXJuKGNvbG9yKSB7XG4gICAgICAgIGlmICh0aGlzLl90dXJuID09IGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlKCctLScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHVybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R1cm47XG4gICAgfVxuICAgIGJvYXJkKCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgbGV0IHJvdyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcm93LnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3cucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZTogYWxnZWJyYWljKGkpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLl9ib2FyZFtpXS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5fYm9hcmRbaV0uY29sb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIHJvdyA9IFtdO1xuICAgICAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBzcXVhcmVDb2xvcihzcXVhcmUpIHtcbiAgICAgICAgaWYgKHNxdWFyZSBpbiBPeDg4KSB7XG4gICAgICAgICAgICBjb25zdCBzcSA9IE94ODhbc3F1YXJlXTtcbiAgICAgICAgICAgIHJldHVybiAocmFuayhzcSkgKyBmaWxlKHNxKSkgJSAyID09PSAwID8gJ2xpZ2h0JyA6ICdkYXJrJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaGlzdG9yeSh7IHZlcmJvc2UgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRIaXN0b3J5ID0gW107XG4gICAgICAgIGNvbnN0IG1vdmVIaXN0b3J5ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldmVyc2VkSGlzdG9yeS5wdXNoKHRoaXMuX3VuZG9Nb3ZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgICAgIG1vdmVIaXN0b3J5LnB1c2gobmV3IE1vdmUodGhpcywgbW92ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW92ZUhpc3RvcnkucHVzaCh0aGlzLl9tb3ZlVG9TYW4obW92ZSwgdGhpcy5fbW92ZXMoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmVIaXN0b3J5O1xuICAgIH1cbiAgICAvKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHBvc2l0aW9uIG9jY3VycmVuY2UgY291bnRzIGZvciB0aGUgcHVycG9zZSBvZiByZXBldGl0aW9uXG4gICAgICogY2hlY2tpbmcuIE9sZCBwb3NpdGlvbnMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGlmIHRoZWlyIGNvdW50cyBhcmUgcmVkdWNlZCB0byAwLlxuICAgICAqL1xuICAgIF9nZXRQb3NpdGlvbkNvdW50KGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uQ291bnQuZ2V0KGhhc2gpID8/IDA7XG4gICAgfVxuICAgIF9pbmNQb3NpdGlvbkNvdW50KCkge1xuICAgICAgICB0aGlzLl9wb3NpdGlvbkNvdW50LnNldCh0aGlzLl9oYXNoLCAodGhpcy5fcG9zaXRpb25Db3VudC5nZXQodGhpcy5faGFzaCkgPz8gMCkgKyAxKTtcbiAgICB9XG4gICAgX2RlY1Bvc2l0aW9uQ291bnQoaGFzaCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q291bnQgPSB0aGlzLl9wb3NpdGlvbkNvdW50LmdldChoYXNoKSA/PyAwO1xuICAgICAgICBpZiAoY3VycmVudENvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkNvdW50LmRlbGV0ZShoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uQ291bnQuc2V0KGhhc2gsIGN1cnJlbnRDb3VudCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcnVuZUNvbW1lbnRzKCkge1xuICAgICAgICBjb25zdCByZXZlcnNlZEhpc3RvcnkgPSBbXTtcbiAgICAgICAgY29uc3QgY3VycmVudENvbW1lbnRzID0ge307XG4gICAgICAgIGNvbnN0IGNvcHlDb21tZW50ID0gKGZlbikgPT4ge1xuICAgICAgICAgICAgaWYgKGZlbiBpbiB0aGlzLl9jb21tZW50cykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb21tZW50c1tmZW5dID0gdGhpcy5fY29tbWVudHNbZmVuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV2ZXJzZWRIaXN0b3J5LnB1c2godGhpcy5fdW5kb01vdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29weUNvbW1lbnQodGhpcy5mZW4oKSk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcbiAgICAgICAgICAgIGNvcHlDb21tZW50KHRoaXMuZmVuKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbW1lbnRzID0gY3VycmVudENvbW1lbnRzO1xuICAgIH1cbiAgICBnZXRDb21tZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgfVxuICAgIHNldENvbW1lbnQoY29tbWVudCkge1xuICAgICAgICB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXSA9IGNvbW1lbnQucmVwbGFjZSgneycsICdbJykucmVwbGFjZSgnfScsICddJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFJlbmFtZWQgdG8gYHJlbW92ZUNvbW1lbnRgIGZvciBjb25zaXN0ZW5jeVxuICAgICAqL1xuICAgIGRlbGV0ZUNvbW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNvbW1lbnQoKTtcbiAgICB9XG4gICAgcmVtb3ZlQ29tbWVudCgpIHtcbiAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldO1xuICAgICAgICBkZWxldGUgdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH1cbiAgICBnZXRDb21tZW50cygpIHtcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY29tbWVudHMpLm1hcCgoZmVuKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBmZW46IGZlbiwgY29tbWVudDogdGhpcy5fY29tbWVudHNbZmVuXSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBgcmVtb3ZlQ29tbWVudHNgIGZvciBjb25zaXN0ZW5jeVxuICAgICAqL1xuICAgIGRlbGV0ZUNvbW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVDb21tZW50cygpO1xuICAgIH1cbiAgICByZW1vdmVDb21tZW50cygpIHtcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY29tbWVudHMpLm1hcCgoZmVuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5fY29tbWVudHNbZmVuXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tZW50c1tmZW5dO1xuICAgICAgICAgICAgcmV0dXJuIHsgZmVuOiBmZW4sIGNvbW1lbnQ6IGNvbW1lbnQgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldENhc3RsaW5nUmlnaHRzKGNvbG9yLCByaWdodHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzaWRlIG9mIFtLSU5HLCBRVUVFTl0pIHtcbiAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbY29sb3JdIHw9IFNJREVTW3NpZGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbY29sb3JdICY9IH5TSURFU1tzaWRlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FzdGxpbmdSaWdodHMoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRDYXN0bGluZ1JpZ2h0cyhjb2xvcik7XG4gICAgICAgIHJldHVybiAoKHJpZ2h0c1tLSU5HXSA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0c1tLSU5HXSA9PT0gcmVzdWx0W0tJTkddKSAmJlxuICAgICAgICAgICAgKHJpZ2h0c1tRVUVFTl0gPT09IHVuZGVmaW5lZCB8fCByaWdodHNbUVVFRU5dID09PSByZXN1bHRbUVVFRU5dKSk7XG4gICAgfVxuICAgIGdldENhc3RsaW5nUmlnaHRzKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbS0lOR106ICh0aGlzLl9jYXN0bGluZ1tjb2xvcl0gJiBTSURFU1tLSU5HXSkgIT09IDAsXG4gICAgICAgICAgICBbUVVFRU5dOiAodGhpcy5fY2FzdGxpbmdbY29sb3JdICYgU0lERVNbUVVFRU5dKSAhPT0gMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbW92ZU51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdmVOdW1iZXI7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCSVNIT1AsIEJMQUNLLCBDaGVzcywgREVGQVVMVF9QT1NJVElPTiwgS0lORywgS05JR0hULCBNb3ZlLCBQQVdOLCBRVUVFTiwgUk9PSywgU0VWRU5fVEFHX1JPU1RFUiwgU1FVQVJFUywgV0hJVEUsIHZhbGlkYXRlRmVuLCB4b3Jvc2hpcm8xMjggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZXNzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/chess.js@1.4.0/node_modules/chess.js/dist/esm/chess.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ChessBoard.tsx":
/*!***************************************!*\
  !*** ./src/components/ChessBoard.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ChessBoard; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst files = [\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\"\n];\nconst ranks = [\n    8,\n    7,\n    6,\n    5,\n    4,\n    3,\n    2,\n    1\n];\nconst pieceGlyphs = {\n    w: {\n        k: \"\",\n        q: \"\",\n        r: \"\",\n        b: \"\",\n        n: \"\",\n        p: \"\"\n    },\n    b: {\n        k: \"\",\n        q: \"\",\n        r: \"\",\n        b: \"\",\n        n: \"\",\n        p: \"\"\n    }\n};\nfunction indexToSquare(row, col) {\n    const file = files[col];\n    const rank = ranks[row];\n    return \"\".concat(file).concat(rank);\n}\nfunction renderPieceGlyph(color, type) {\n    var _pieceGlyphs_color_type;\n    return (_pieceGlyphs_color_type = pieceGlyphs[color][type]) !== null && _pieceGlyphs_color_type !== void 0 ? _pieceGlyphs_color_type : \"\";\n}\nfunction ChessBoard(param) {\n    let { board, selectedSquare, legalMoves, onSquareClick } = param;\n    const legalTargets = new Set(legalMoves.map((move)=>move.to));\n    const captureTargets = new Set(legalMoves.filter((move)=>move.flags.includes(\"c\") || move.flags.includes(\"e\")).map((move)=>move.to));\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex w-full max-w-xl flex-col items-center\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"grid aspect-square w-full grid-cols-8 overflow-hidden rounded-xl shadow-2xl shadow-slate-950\",\n            children: board.map((row, rowIndex)=>row.map((piece, colIndex)=>{\n                    const square = indexToSquare(rowIndex, colIndex);\n                    const isDarkSquare = (rowIndex + colIndex) % 2 === 1;\n                    const isSelected = selectedSquare === square;\n                    const isLegalTarget = legalTargets.has(square);\n                    const isCaptureTarget = captureTargets.has(square);\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: ()=>onSquareClick(square),\n                        className: classnames__WEBPACK_IMPORTED_MODULE_1___default()(\"relative flex aspect-square items-center justify-center text-3xl font-semibold transition-colors sm:text-4xl\", isDarkSquare ? \"bg-slate-700 text-slate-100\" : \"bg-slate-200 text-slate-900\", isSelected && \"ring-4 ring-amber-400\"),\n                        \"aria-label\": \"Square \".concat(square),\n                        children: [\n                            piece ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: renderPieceGlyph(piece.color, piece.type)\n                            }, void 0, false, {\n                                fileName: \"/workspaces/chess-codex/src/components/ChessBoard.tsx\",\n                                lineNumber: 78,\n                                columnNumber: 26\n                            }, this) : null,\n                            isLegalTarget ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: classnames__WEBPACK_IMPORTED_MODULE_1___default()(\"pointer-events-none absolute inset-2 rounded-full\", isCaptureTarget ? \"border-4 border-amber-400\" : \"bg-amber-300/60\")\n                            }, void 0, false, {\n                                fileName: \"/workspaces/chess-codex/src/components/ChessBoard.tsx\",\n                                lineNumber: 80,\n                                columnNumber: 19\n                            }, this) : null,\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"pointer-events-none absolute bottom-1 left-1 text-xs font-medium text-slate-500\",\n                                children: square\n                            }, void 0, false, {\n                                fileName: \"/workspaces/chess-codex/src/components/ChessBoard.tsx\",\n                                lineNumber: 87,\n                                columnNumber: 17\n                            }, this)\n                        ]\n                    }, square, true, {\n                        fileName: \"/workspaces/chess-codex/src/components/ChessBoard.tsx\",\n                        lineNumber: 67,\n                        columnNumber: 15\n                    }, this);\n                }))\n        }, void 0, false, {\n            fileName: \"/workspaces/chess-codex/src/components/ChessBoard.tsx\",\n            lineNumber: 57,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/workspaces/chess-codex/src/components/ChessBoard.tsx\",\n        lineNumber: 56,\n        columnNumber: 5\n    }, this);\n}\n_c = ChessBoard;\nvar _c;\n$RefreshReg$(_c, \"ChessBoard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoZXNzQm9hcmQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9DO0FBV3BDLE1BQU1DLFFBQVE7SUFBQztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFDdEQsTUFBTUMsUUFBUTtJQUFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7Q0FBRTtBQUV0QyxNQUFNQyxjQUFzQztJQUMxQ0MsR0FBRztRQUNEQyxHQUFHO1FBQ0hDLEdBQUc7UUFDSEMsR0FBRztRQUNIQyxHQUFHO1FBQ0hDLEdBQUc7UUFDSEMsR0FBRztJQUNMO0lBQ0FGLEdBQUc7UUFDREgsR0FBRztRQUNIQyxHQUFHO1FBQ0hDLEdBQUc7UUFDSEMsR0FBRztRQUNIQyxHQUFHO1FBQ0hDLEdBQUc7SUFDTDtBQUNGO0FBRUEsU0FBU0MsY0FBY0MsR0FBVyxFQUFFQyxHQUFXO0lBQzdDLE1BQU1DLE9BQU9iLEtBQUssQ0FBQ1ksSUFBSTtJQUN2QixNQUFNRSxPQUFPYixLQUFLLENBQUNVLElBQUk7SUFDdkIsT0FBTyxHQUFVRyxPQUFQRCxNQUFZLE9BQUxDO0FBQ25CO0FBRUEsU0FBU0MsaUJBQWlCQyxLQUFnQixFQUFFQyxJQUFZO1FBQy9DZjtJQUFQLE9BQU9BLENBQUFBLDBCQUFBQSxXQUFXLENBQUNjLE1BQU0sQ0FBQ0MsS0FBSyxjQUF4QmYscUNBQUFBLDBCQUE0QjtBQUNyQztBQUVlLFNBQVNnQixXQUFXLEtBS2pCO1FBTGlCLEVBQ2pDQyxLQUFLLEVBQ0xDLGNBQWMsRUFDZEMsVUFBVSxFQUNWQyxhQUFhLEVBQ0csR0FMaUI7SUFNakMsTUFBTUMsZUFBZSxJQUFJQyxJQUFJSCxXQUFXSSxHQUFHLENBQUMsQ0FBQ0MsT0FBU0EsS0FBS0MsRUFBRTtJQUM3RCxNQUFNQyxpQkFBaUIsSUFBSUosSUFDekJILFdBQVdRLE1BQU0sQ0FBQyxDQUFDSCxPQUFTQSxLQUFLSSxLQUFLLENBQUNDLFFBQVEsQ0FBQyxRQUFRTCxLQUFLSSxLQUFLLENBQUNDLFFBQVEsQ0FBQyxNQUFNTixHQUFHLENBQUMsQ0FBQ0MsT0FBU0EsS0FBS0MsRUFBRTtJQUd6RyxxQkFDRSw4REFBQ0s7UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ0Q7WUFBSUMsV0FBVTtzQkFDWmQsTUFBTU0sR0FBRyxDQUFDLENBQUNkLEtBQUt1QixXQUNmdkIsSUFBSWMsR0FBRyxDQUFDLENBQUNVLE9BQU9DO29CQUNkLE1BQU1DLFNBQVMzQixjQUFjd0IsVUFBVUU7b0JBQ3ZDLE1BQU1FLGVBQWUsQ0FBQ0osV0FBV0UsUUFBTyxJQUFLLE1BQU07b0JBQ25ELE1BQU1HLGFBQWFuQixtQkFBbUJpQjtvQkFDdEMsTUFBTUcsZ0JBQWdCakIsYUFBYWtCLEdBQUcsQ0FBQ0o7b0JBQ3ZDLE1BQU1LLGtCQUFrQmQsZUFBZWEsR0FBRyxDQUFDSjtvQkFFM0MscUJBQ0UsOERBQUNNO3dCQUVDMUIsTUFBSzt3QkFDTDJCLFNBQVMsSUFBTXRCLGNBQWNlO3dCQUM3QkosV0FBV2xDLGlEQUFVQSxDQUNuQixnSEFDQXVDLGVBQWUsZ0NBQWdDLCtCQUMvQ0MsY0FBYzt3QkFFaEJNLGNBQVksVUFBaUIsT0FBUFI7OzRCQUVyQkYsc0JBQVEsOERBQUNXOzBDQUFNL0IsaUJBQWlCb0IsTUFBTW5CLEtBQUssRUFBRW1CLE1BQU1sQixJQUFJOzs7Ozt1Q0FBWTs0QkFDbkV1Qiw4QkFDQyw4REFBQ007Z0NBQ0NiLFdBQVdsQyxpREFBVUEsQ0FDbkIscURBQ0EyQyxrQkFBa0IsOEJBQThCOzs7Ozt1Q0FHbEQ7MENBQ0osOERBQUNJO2dDQUFLYixXQUFVOzBDQUNiSTs7Ozs7Ozt1QkFwQkVBOzs7OztnQkF3Qlg7Ozs7Ozs7Ozs7O0FBS1Y7S0FyRHdCbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvQ2hlc3NCb2FyZC50c3g/ZWY5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2xhc3NOYW1lcyBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuaW1wb3J0IHR5cGUgeyBNb3ZlLCBTcXVhcmUgfSBmcm9tIFwiY2hlc3MuanNcIjtcbmltcG9ydCB0eXBlIHsgQm9hcmRTdGF0ZSB9IGZyb20gXCJAL2xpYi9jaGVzc1wiO1xuXG50eXBlIENoZXNzQm9hcmRQcm9wcyA9IHtcbiAgYm9hcmQ6IEJvYXJkU3RhdGU7XG4gIHNlbGVjdGVkU3F1YXJlOiBTcXVhcmUgfCBudWxsO1xuICBsZWdhbE1vdmVzOiBNb3ZlW107XG4gIG9uU3F1YXJlQ2xpY2s6IChzcXVhcmU6IFNxdWFyZSkgPT4gdm9pZDtcbn07XG5cbmNvbnN0IGZpbGVzID0gW1wiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImVcIiwgXCJmXCIsIFwiZ1wiLCBcImhcIl0gYXMgY29uc3Q7XG5jb25zdCByYW5rcyA9IFs4LCA3LCA2LCA1LCA0LCAzLCAyLCAxXSBhcyBjb25zdDtcblxuY29uc3QgcGllY2VHbHlwaHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gIHc6IHtcbiAgICBrOiBcIuKZlFwiLFxuICAgIHE6IFwi4pmVXCIsXG4gICAgcjogXCLimZZcIixcbiAgICBiOiBcIuKZl1wiLFxuICAgIG46IFwi4pmYXCIsXG4gICAgcDogXCLimZlcIlxuICB9LFxuICBiOiB7XG4gICAgazogXCLimZpcIixcbiAgICBxOiBcIuKZm1wiLFxuICAgIHI6IFwi4pmcXCIsXG4gICAgYjogXCLimZ1cIixcbiAgICBuOiBcIuKZnlwiLFxuICAgIHA6IFwi4pmfXCJcbiAgfVxufSBhcyBjb25zdCBzYXRpc2ZpZXMgUmVjb3JkPFwid1wiIHwgXCJiXCIsIFJlY29yZDxzdHJpbmcsIHN0cmluZz4+O1xuXG5mdW5jdGlvbiBpbmRleFRvU3F1YXJlKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcik6IFNxdWFyZSB7XG4gIGNvbnN0IGZpbGUgPSBmaWxlc1tjb2xdO1xuICBjb25zdCByYW5rID0gcmFua3Nbcm93XTtcbiAgcmV0dXJuIGAke2ZpbGV9JHtyYW5rfWAgYXMgU3F1YXJlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQaWVjZUdseXBoKGNvbG9yOiBcIndcIiB8IFwiYlwiLCB0eXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcGllY2VHbHlwaHNbY29sb3JdW3R5cGVdID8/IFwiXCI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENoZXNzQm9hcmQoe1xuICBib2FyZCxcbiAgc2VsZWN0ZWRTcXVhcmUsXG4gIGxlZ2FsTW92ZXMsXG4gIG9uU3F1YXJlQ2xpY2tcbn06IENoZXNzQm9hcmRQcm9wcyk6IEpTWC5FbGVtZW50IHtcbiAgY29uc3QgbGVnYWxUYXJnZXRzID0gbmV3IFNldChsZWdhbE1vdmVzLm1hcCgobW92ZSkgPT4gbW92ZS50bykpO1xuICBjb25zdCBjYXB0dXJlVGFyZ2V0cyA9IG5ldyBTZXQoXG4gICAgbGVnYWxNb3Zlcy5maWx0ZXIoKG1vdmUpID0+IG1vdmUuZmxhZ3MuaW5jbHVkZXMoXCJjXCIpIHx8IG1vdmUuZmxhZ3MuaW5jbHVkZXMoXCJlXCIpKS5tYXAoKG1vdmUpID0+IG1vdmUudG8pXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggdy1mdWxsIG1heC13LXhsIGZsZXgtY29sIGl0ZW1zLWNlbnRlclwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGFzcGVjdC1zcXVhcmUgdy1mdWxsIGdyaWQtY29scy04IG92ZXJmbG93LWhpZGRlbiByb3VuZGVkLXhsIHNoYWRvdy0yeGwgc2hhZG93LXNsYXRlLTk1MFwiPlxuICAgICAgICB7Ym9hcmQubWFwKChyb3csIHJvd0luZGV4KSA9PlxuICAgICAgICAgIHJvdy5tYXAoKHBpZWNlLCBjb2xJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3F1YXJlID0gaW5kZXhUb1NxdWFyZShyb3dJbmRleCwgY29sSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgaXNEYXJrU3F1YXJlID0gKHJvd0luZGV4ICsgY29sSW5kZXgpICUgMiA9PT0gMTtcbiAgICAgICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZFNxdWFyZSA9PT0gc3F1YXJlO1xuICAgICAgICAgICAgY29uc3QgaXNMZWdhbFRhcmdldCA9IGxlZ2FsVGFyZ2V0cy5oYXMoc3F1YXJlKTtcbiAgICAgICAgICAgIGNvbnN0IGlzQ2FwdHVyZVRhcmdldCA9IGNhcHR1cmVUYXJnZXRzLmhhcyhzcXVhcmUpO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAga2V5PXtzcXVhcmV9XG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gb25TcXVhcmVDbGljayhzcXVhcmUpfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgICAgICAgICAgIFwicmVsYXRpdmUgZmxleCBhc3BlY3Qtc3F1YXJlIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB0ZXh0LTN4bCBmb250LXNlbWlib2xkIHRyYW5zaXRpb24tY29sb3JzIHNtOnRleHQtNHhsXCIsXG4gICAgICAgICAgICAgICAgICBpc0RhcmtTcXVhcmUgPyBcImJnLXNsYXRlLTcwMCB0ZXh0LXNsYXRlLTEwMFwiIDogXCJiZy1zbGF0ZS0yMDAgdGV4dC1zbGF0ZS05MDBcIixcbiAgICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgJiYgXCJyaW5nLTQgcmluZy1hbWJlci00MDBcIlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17YFNxdWFyZSAke3NxdWFyZX1gfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3BpZWNlID8gPHNwYW4+e3JlbmRlclBpZWNlR2x5cGgocGllY2UuY29sb3IsIHBpZWNlLnR5cGUpfTwvc3Bhbj4gOiBudWxsfVxuICAgICAgICAgICAgICAgIHtpc0xlZ2FsVGFyZ2V0ID8gKFxuICAgICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgICAgICAgIFwicG9pbnRlci1ldmVudHMtbm9uZSBhYnNvbHV0ZSBpbnNldC0yIHJvdW5kZWQtZnVsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGlzQ2FwdHVyZVRhcmdldCA/IFwiYm9yZGVyLTQgYm9yZGVyLWFtYmVyLTQwMFwiIDogXCJiZy1hbWJlci0zMDAvNjBcIlxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJwb2ludGVyLWV2ZW50cy1ub25lIGFic29sdXRlIGJvdHRvbS0xIGxlZnQtMSB0ZXh0LXhzIGZvbnQtbWVkaXVtIHRleHQtc2xhdGUtNTAwXCI+XG4gICAgICAgICAgICAgICAgICB7c3F1YXJlfVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pXG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJjbGFzc05hbWVzIiwiZmlsZXMiLCJyYW5rcyIsInBpZWNlR2x5cGhzIiwidyIsImsiLCJxIiwiciIsImIiLCJuIiwicCIsImluZGV4VG9TcXVhcmUiLCJyb3ciLCJjb2wiLCJmaWxlIiwicmFuayIsInJlbmRlclBpZWNlR2x5cGgiLCJjb2xvciIsInR5cGUiLCJDaGVzc0JvYXJkIiwiYm9hcmQiLCJzZWxlY3RlZFNxdWFyZSIsImxlZ2FsTW92ZXMiLCJvblNxdWFyZUNsaWNrIiwibGVnYWxUYXJnZXRzIiwiU2V0IiwibWFwIiwibW92ZSIsInRvIiwiY2FwdHVyZVRhcmdldHMiLCJmaWx0ZXIiLCJmbGFncyIsImluY2x1ZGVzIiwiZGl2IiwiY2xhc3NOYW1lIiwicm93SW5kZXgiLCJwaWVjZSIsImNvbEluZGV4Iiwic3F1YXJlIiwiaXNEYXJrU3F1YXJlIiwiaXNTZWxlY3RlZCIsImlzTGVnYWxUYXJnZXQiLCJoYXMiLCJpc0NhcHR1cmVUYXJnZXQiLCJidXR0b24iLCJvbkNsaWNrIiwiYXJpYS1sYWJlbCIsInNwYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ChessBoard.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ChessGame.tsx":
/*!**************************************!*\
  !*** ./src/components/ChessGame.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ChessGame; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_ChessBoard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/ChessBoard */ \"(app-pages-browser)/./src/components/ChessBoard.tsx\");\n/* harmony import */ var _lib_chess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/chess */ \"(app-pages-browser)/./src/lib/chess.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction colorName(color) {\n    return color === \"w\" ? \"White\" : \"Black\";\n}\nfunction oppositeColor(color) {\n    return color === \"w\" ? \"b\" : \"w\";\n}\nfunction getStatus(game) {\n    if (game.isCheckmate()) {\n        return \"\".concat(colorName(oppositeColor(game.turn())), \" wins by checkmate\");\n    }\n    if (game.isStalemate()) {\n        return \"Stalemate\";\n    }\n    if (game.isDraw()) {\n        return \"Draw\";\n    }\n    const turn = game.turn();\n    const checkSuffix = game.inCheck() ? \" (in check)\" : \"\";\n    return \"\".concat(colorName(turn), \" to move\").concat(checkSuffix);\n}\nfunction ChessGame() {\n    _s();\n    const gameRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)((0,_lib_chess__WEBPACK_IMPORTED_MODULE_3__.createGame)());\n    const [board, setBoard] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(gameRef.current.board());\n    const [selectedSquare, setSelectedSquare] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [legalMoves, setLegalMoves] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(getStatus(gameRef.current));\n    const refresh = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setBoard(gameRef.current.board());\n        setStatus(getStatus(gameRef.current));\n    }, []);\n    const handleSelectSquare = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((square)=>{\n        const game = gameRef.current;\n        if (selectedSquare) {\n            if (selectedSquare === square) {\n                setSelectedSquare(null);\n                setLegalMoves([]);\n                return;\n            }\n            const targetMove = legalMoves.find((move)=>move.to === square);\n            if (targetMove) {\n                const moveResult = (0,_lib_chess__WEBPACK_IMPORTED_MODULE_3__.makeMove)(game, selectedSquare, square, targetMove.promotion);\n                if (moveResult) {\n                    setSelectedSquare(null);\n                    setLegalMoves([]);\n                    refresh();\n                    return;\n                }\n            }\n        }\n        const piece = game.get(square);\n        if (piece && piece.color === game.turn()) {\n            setSelectedSquare(square);\n            setLegalMoves((0,_lib_chess__WEBPACK_IMPORTED_MODULE_3__.getLegalMoves)(game, square));\n        } else {\n            setSelectedSquare(null);\n            setLegalMoves([]);\n        }\n    }, [\n        legalMoves,\n        refresh,\n        selectedSquare\n    ]);\n    const handleNewGame = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        gameRef.current = (0,_lib_chess__WEBPACK_IMPORTED_MODULE_3__.createGame)();\n        setSelectedSquare(null);\n        setLegalMoves([]);\n        refresh();\n    }, [\n        refresh\n    ]);\n    const handleUndo = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        (0,_lib_chess__WEBPACK_IMPORTED_MODULE_3__.undoMove)(gameRef.current);\n        setSelectedSquare(null);\n        setLegalMoves([]);\n        refresh();\n    }, [\n        refresh\n    ]);\n    const canUndo = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>gameRef.current.history().length > 0, [\n        board\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n        className: \"flex w-full flex-col items-center gap-4\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-wrap items-center justify-center gap-3 text-sm text-slate-200\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"rounded-full bg-slate-800 px-4 py-1 font-medium shadow\",\n                        children: status\n                    }, void 0, false, {\n                        fileName: \"/workspaces/chess-codex/src/components/ChessGame.tsx\",\n                        lineNumber: 106,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: handleNewGame,\n                        className: \"rounded-md bg-amber-500 px-4 py-1 text-sm font-semibold text-slate-900 shadow transition hover:bg-amber-400 focus:outline-none focus-visible:ring-2 focus-visible:ring-amber-300\",\n                        children: \"New game\"\n                    }, void 0, false, {\n                        fileName: \"/workspaces/chess-codex/src/components/ChessGame.tsx\",\n                        lineNumber: 107,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: handleUndo,\n                        disabled: !canUndo,\n                        className: \"rounded-md bg-slate-700 px-4 py-1 text-sm font-semibold text-slate-100 shadow transition hover:bg-slate-600 focus:outline-none focus-visible:ring-2 focus-visible:ring-amber-300 disabled:cursor-not-allowed disabled:bg-slate-800 disabled:text-slate-400\",\n                        children: \"Undo\"\n                    }, void 0, false, {\n                        fileName: \"/workspaces/chess-codex/src/components/ChessGame.tsx\",\n                        lineNumber: 114,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/workspaces/chess-codex/src/components/ChessGame.tsx\",\n                lineNumber: 105,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ChessBoard__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                board: board,\n                selectedSquare: selectedSquare,\n                legalMoves: legalMoves,\n                onSquareClick: handleSelectSquare\n            }, void 0, false, {\n                fileName: \"/workspaces/chess-codex/src/components/ChessGame.tsx\",\n                lineNumber: 123,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/workspaces/chess-codex/src/components/ChessGame.tsx\",\n        lineNumber: 104,\n        columnNumber: 5\n    }, this);\n}\n_s(ChessGame, \"hOjOWDTQgRYTHeYM5YgK9CCGX/g=\");\n_c = ChessGame;\nvar _c;\n$RefreshReg$(_c, \"ChessGame\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoZXNzR2FtZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFK0Q7QUFFZDtBQU81QjtBQUVyQixTQUFTUyxVQUFVQyxLQUFZO0lBQzdCLE9BQU9BLFVBQVUsTUFBTSxVQUFVO0FBQ25DO0FBRUEsU0FBU0MsY0FBY0QsS0FBWTtJQUNqQyxPQUFPQSxVQUFVLE1BQU0sTUFBTTtBQUMvQjtBQUVBLFNBQVNFLFVBQVVDLElBQStHO0lBQ2hJLElBQUlBLEtBQUtDLFdBQVcsSUFBSTtRQUN0QixPQUFPLEdBQXlDLE9BQXRDTCxVQUFVRSxjQUFjRSxLQUFLRSxJQUFJLE1BQUs7SUFDbEQ7SUFFQSxJQUFJRixLQUFLRyxXQUFXLElBQUk7UUFDdEIsT0FBTztJQUNUO0lBRUEsSUFBSUgsS0FBS0ksTUFBTSxJQUFJO1FBQ2pCLE9BQU87SUFDVDtJQUVBLE1BQU1GLE9BQU9GLEtBQUtFLElBQUk7SUFDdEIsTUFBTUcsY0FBY0wsS0FBS00sT0FBTyxLQUFLLGdCQUFnQjtJQUNyRCxPQUFPLEdBQTZCRCxPQUExQlQsVUFBVU0sT0FBTSxZQUFzQixPQUFaRztBQUN0QztBQUVlLFNBQVNFOztJQUN0QixNQUFNQyxVQUFVbkIsNkNBQU1BLENBQUNHLHNEQUFVQTtJQUNqQyxNQUFNLENBQUNpQixPQUFPQyxTQUFTLEdBQUdwQiwrQ0FBUUEsQ0FBYWtCLFFBQVFHLE9BQU8sQ0FBQ0YsS0FBSztJQUNwRSxNQUFNLENBQUNHLGdCQUFnQkMsa0JBQWtCLEdBQUd2QiwrQ0FBUUEsQ0FBZ0I7SUFDcEUsTUFBTSxDQUFDd0IsWUFBWUMsY0FBYyxHQUFHekIsK0NBQVFBLENBQVMsRUFBRTtJQUN2RCxNQUFNLENBQUMwQixRQUFRQyxVQUFVLEdBQUczQiwrQ0FBUUEsQ0FBU1MsVUFBVVMsUUFBUUcsT0FBTztJQUV0RSxNQUFNTyxVQUFVL0Isa0RBQVdBLENBQUM7UUFDMUJ1QixTQUFTRixRQUFRRyxPQUFPLENBQUNGLEtBQUs7UUFDOUJRLFVBQVVsQixVQUFVUyxRQUFRRyxPQUFPO0lBQ3JDLEdBQUcsRUFBRTtJQUVMLE1BQU1RLHFCQUFxQmhDLGtEQUFXQSxDQUNwQyxDQUFDaUM7UUFDQyxNQUFNcEIsT0FBT1EsUUFBUUcsT0FBTztRQUU1QixJQUFJQyxnQkFBZ0I7WUFDbEIsSUFBSUEsbUJBQW1CUSxRQUFRO2dCQUM3QlAsa0JBQWtCO2dCQUNsQkUsY0FBYyxFQUFFO2dCQUNoQjtZQUNGO1lBRUEsTUFBTU0sYUFBYVAsV0FBV1EsSUFBSSxDQUFDLENBQUNDLE9BQVNBLEtBQUtDLEVBQUUsS0FBS0o7WUFDekQsSUFBSUMsWUFBWTtnQkFDZCxNQUFNSSxhQUFhL0Isb0RBQVFBLENBQUNNLE1BQU1ZLGdCQUFnQlEsUUFBUUMsV0FBV0ssU0FBUztnQkFDOUUsSUFBSUQsWUFBWTtvQkFDZFosa0JBQWtCO29CQUNsQkUsY0FBYyxFQUFFO29CQUNoQkc7b0JBQ0E7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsTUFBTVMsUUFBUTNCLEtBQUs0QixHQUFHLENBQUNSO1FBQ3ZCLElBQUlPLFNBQVNBLE1BQU05QixLQUFLLEtBQUtHLEtBQUtFLElBQUksSUFBSTtZQUN4Q1csa0JBQWtCTztZQUNsQkwsY0FBY3RCLHlEQUFhQSxDQUFDTyxNQUFNb0I7UUFDcEMsT0FBTztZQUNMUCxrQkFBa0I7WUFDbEJFLGNBQWMsRUFBRTtRQUNsQjtJQUNGLEdBQ0E7UUFBQ0Q7UUFBWUk7UUFBU047S0FBZTtJQUd2QyxNQUFNaUIsZ0JBQWdCMUMsa0RBQVdBLENBQUM7UUFDaENxQixRQUFRRyxPQUFPLEdBQUduQixzREFBVUE7UUFDNUJxQixrQkFBa0I7UUFDbEJFLGNBQWMsRUFBRTtRQUNoQkc7SUFDRixHQUFHO1FBQUNBO0tBQVE7SUFFWixNQUFNWSxhQUFhM0Msa0RBQVdBLENBQUM7UUFDN0JRLG9EQUFRQSxDQUFDYSxRQUFRRyxPQUFPO1FBQ3hCRSxrQkFBa0I7UUFDbEJFLGNBQWMsRUFBRTtRQUNoQkc7SUFDRixHQUFHO1FBQUNBO0tBQVE7SUFFWixNQUFNYSxVQUFVM0MsOENBQU9BLENBQUMsSUFBTW9CLFFBQVFHLE9BQU8sQ0FBQ3FCLE9BQU8sR0FBR0MsTUFBTSxHQUFHLEdBQUc7UUFBQ3hCO0tBQU07SUFFM0UscUJBQ0UsOERBQUN5QjtRQUFRQyxXQUFVOzswQkFDakIsOERBQUNDO2dCQUFJRCxXQUFVOztrQ0FDYiw4REFBQ0U7d0JBQUtGLFdBQVU7a0NBQTBEbkI7Ozs7OztrQ0FDMUUsOERBQUNzQjt3QkFDQ0MsTUFBSzt3QkFDTEMsU0FBU1g7d0JBQ1RNLFdBQVU7a0NBQ1g7Ozs7OztrQ0FHRCw4REFBQ0c7d0JBQ0NDLE1BQUs7d0JBQ0xDLFNBQVNWO3dCQUNUVyxVQUFVLENBQUNWO3dCQUNYSSxXQUFVO2tDQUNYOzs7Ozs7Ozs7Ozs7MEJBSUgsOERBQUM1Qyw4REFBVUE7Z0JBQ1RrQixPQUFPQTtnQkFDUEcsZ0JBQWdCQTtnQkFDaEJFLFlBQVlBO2dCQUNaNEIsZUFBZXZCOzs7Ozs7Ozs7Ozs7QUFJdkI7R0EzRndCWjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9DaGVzc0dhbWUudHN4PzY0ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IENvbG9yLCBNb3ZlLCBTcXVhcmUgfSBmcm9tIFwiY2hlc3MuanNcIjtcbmltcG9ydCBDaGVzc0JvYXJkIGZyb20gXCJAL2NvbXBvbmVudHMvQ2hlc3NCb2FyZFwiO1xuaW1wb3J0IHtcbiAgQm9hcmRTdGF0ZSxcbiAgY3JlYXRlR2FtZSxcbiAgZ2V0TGVnYWxNb3ZlcyxcbiAgbWFrZU1vdmUsXG4gIHVuZG9Nb3ZlXG59IGZyb20gXCJAL2xpYi9jaGVzc1wiO1xuXG5mdW5jdGlvbiBjb2xvck5hbWUoY29sb3I6IENvbG9yKTogc3RyaW5nIHtcbiAgcmV0dXJuIGNvbG9yID09PSBcIndcIiA/IFwiV2hpdGVcIiA6IFwiQmxhY2tcIjtcbn1cblxuZnVuY3Rpb24gb3Bwb3NpdGVDb2xvcihjb2xvcjogQ29sb3IpOiBDb2xvciB7XG4gIHJldHVybiBjb2xvciA9PT0gXCJ3XCIgPyBcImJcIiA6IFwid1wiO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0dXMoZ2FtZTogeyB0dXJuKCk6IENvbG9yOyBpc0NoZWNrbWF0ZSgpOiBib29sZWFuOyBpc1N0YWxlbWF0ZSgpOiBib29sZWFuOyBpc0RyYXcoKTogYm9vbGVhbjsgaW5DaGVjaygpOiBib29sZWFuOyB9KTogc3RyaW5nIHtcbiAgaWYgKGdhbWUuaXNDaGVja21hdGUoKSkge1xuICAgIHJldHVybiBgJHtjb2xvck5hbWUob3Bwb3NpdGVDb2xvcihnYW1lLnR1cm4oKSkpfSB3aW5zIGJ5IGNoZWNrbWF0ZWA7XG4gIH1cblxuICBpZiAoZ2FtZS5pc1N0YWxlbWF0ZSgpKSB7XG4gICAgcmV0dXJuIFwiU3RhbGVtYXRlXCI7XG4gIH1cblxuICBpZiAoZ2FtZS5pc0RyYXcoKSkge1xuICAgIHJldHVybiBcIkRyYXdcIjtcbiAgfVxuXG4gIGNvbnN0IHR1cm4gPSBnYW1lLnR1cm4oKTtcbiAgY29uc3QgY2hlY2tTdWZmaXggPSBnYW1lLmluQ2hlY2soKSA/IFwiIChpbiBjaGVjaylcIiA6IFwiXCI7XG4gIHJldHVybiBgJHtjb2xvck5hbWUodHVybil9IHRvIG1vdmUke2NoZWNrU3VmZml4fWA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENoZXNzR2FtZSgpOiBKU1guRWxlbWVudCB7XG4gIGNvbnN0IGdhbWVSZWYgPSB1c2VSZWYoY3JlYXRlR2FtZSgpKTtcbiAgY29uc3QgW2JvYXJkLCBzZXRCb2FyZF0gPSB1c2VTdGF0ZTxCb2FyZFN0YXRlPihnYW1lUmVmLmN1cnJlbnQuYm9hcmQoKSk7XG4gIGNvbnN0IFtzZWxlY3RlZFNxdWFyZSwgc2V0U2VsZWN0ZWRTcXVhcmVdID0gdXNlU3RhdGU8U3F1YXJlIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsZWdhbE1vdmVzLCBzZXRMZWdhbE1vdmVzXSA9IHVzZVN0YXRlPE1vdmVbXT4oW10pO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGU8c3RyaW5nPihnZXRTdGF0dXMoZ2FtZVJlZi5jdXJyZW50KSk7XG5cbiAgY29uc3QgcmVmcmVzaCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRCb2FyZChnYW1lUmVmLmN1cnJlbnQuYm9hcmQoKSk7XG4gICAgc2V0U3RhdHVzKGdldFN0YXR1cyhnYW1lUmVmLmN1cnJlbnQpKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGhhbmRsZVNlbGVjdFNxdWFyZSA9IHVzZUNhbGxiYWNrKFxuICAgIChzcXVhcmU6IFNxdWFyZSkgPT4ge1xuICAgICAgY29uc3QgZ2FtZSA9IGdhbWVSZWYuY3VycmVudDtcblxuICAgICAgaWYgKHNlbGVjdGVkU3F1YXJlKSB7XG4gICAgICAgIGlmIChzZWxlY3RlZFNxdWFyZSA9PT0gc3F1YXJlKSB7XG4gICAgICAgICAgc2V0U2VsZWN0ZWRTcXVhcmUobnVsbCk7XG4gICAgICAgICAgc2V0TGVnYWxNb3ZlcyhbXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0TW92ZSA9IGxlZ2FsTW92ZXMuZmluZCgobW92ZSkgPT4gbW92ZS50byA9PT0gc3F1YXJlKTtcbiAgICAgICAgaWYgKHRhcmdldE1vdmUpIHtcbiAgICAgICAgICBjb25zdCBtb3ZlUmVzdWx0ID0gbWFrZU1vdmUoZ2FtZSwgc2VsZWN0ZWRTcXVhcmUsIHNxdWFyZSwgdGFyZ2V0TW92ZS5wcm9tb3Rpb24pO1xuICAgICAgICAgIGlmIChtb3ZlUmVzdWx0KSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZFNxdWFyZShudWxsKTtcbiAgICAgICAgICAgIHNldExlZ2FsTW92ZXMoW10pO1xuICAgICAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwaWVjZSA9IGdhbWUuZ2V0KHNxdWFyZSk7XG4gICAgICBpZiAocGllY2UgJiYgcGllY2UuY29sb3IgPT09IGdhbWUudHVybigpKSB7XG4gICAgICAgIHNldFNlbGVjdGVkU3F1YXJlKHNxdWFyZSk7XG4gICAgICAgIHNldExlZ2FsTW92ZXMoZ2V0TGVnYWxNb3ZlcyhnYW1lLCBzcXVhcmUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkU3F1YXJlKG51bGwpO1xuICAgICAgICBzZXRMZWdhbE1vdmVzKFtdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtsZWdhbE1vdmVzLCByZWZyZXNoLCBzZWxlY3RlZFNxdWFyZV1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVOZXdHYW1lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGdhbWVSZWYuY3VycmVudCA9IGNyZWF0ZUdhbWUoKTtcbiAgICBzZXRTZWxlY3RlZFNxdWFyZShudWxsKTtcbiAgICBzZXRMZWdhbE1vdmVzKFtdKTtcbiAgICByZWZyZXNoKCk7XG4gIH0sIFtyZWZyZXNoXSk7XG5cbiAgY29uc3QgaGFuZGxlVW5kbyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB1bmRvTW92ZShnYW1lUmVmLmN1cnJlbnQpO1xuICAgIHNldFNlbGVjdGVkU3F1YXJlKG51bGwpO1xuICAgIHNldExlZ2FsTW92ZXMoW10pO1xuICAgIHJlZnJlc2goKTtcbiAgfSwgW3JlZnJlc2hdKTtcblxuICBjb25zdCBjYW5VbmRvID0gdXNlTWVtbygoKSA9PiBnYW1lUmVmLmN1cnJlbnQuaGlzdG9yeSgpLmxlbmd0aCA+IDAsIFtib2FyZF0pO1xuXG4gIHJldHVybiAoXG4gICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwiZmxleCB3LWZ1bGwgZmxleC1jb2wgaXRlbXMtY2VudGVyIGdhcC00XCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC13cmFwIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBnYXAtMyB0ZXh0LXNtIHRleHQtc2xhdGUtMjAwXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInJvdW5kZWQtZnVsbCBiZy1zbGF0ZS04MDAgcHgtNCBweS0xIGZvbnQtbWVkaXVtIHNoYWRvd1wiPntzdGF0dXN9PC9zcGFuPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgb25DbGljaz17aGFuZGxlTmV3R2FtZX1cbiAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkLW1kIGJnLWFtYmVyLTUwMCBweC00IHB5LTEgdGV4dC1zbSBmb250LXNlbWlib2xkIHRleHQtc2xhdGUtOTAwIHNoYWRvdyB0cmFuc2l0aW9uIGhvdmVyOmJnLWFtYmVyLTQwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXMtdmlzaWJsZTpyaW5nLTIgZm9jdXMtdmlzaWJsZTpyaW5nLWFtYmVyLTMwMFwiXG4gICAgICAgID5cbiAgICAgICAgICBOZXcgZ2FtZVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVVuZG99XG4gICAgICAgICAgZGlzYWJsZWQ9eyFjYW5VbmRvfVxuICAgICAgICAgIGNsYXNzTmFtZT1cInJvdW5kZWQtbWQgYmctc2xhdGUtNzAwIHB4LTQgcHktMSB0ZXh0LXNtIGZvbnQtc2VtaWJvbGQgdGV4dC1zbGF0ZS0xMDAgc2hhZG93IHRyYW5zaXRpb24gaG92ZXI6Ymctc2xhdGUtNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1cy12aXNpYmxlOnJpbmctMiBmb2N1cy12aXNpYmxlOnJpbmctYW1iZXItMzAwIGRpc2FibGVkOmN1cnNvci1ub3QtYWxsb3dlZCBkaXNhYmxlZDpiZy1zbGF0ZS04MDAgZGlzYWJsZWQ6dGV4dC1zbGF0ZS00MDBcIlxuICAgICAgICA+XG4gICAgICAgICAgVW5kb1xuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPENoZXNzQm9hcmRcbiAgICAgICAgYm9hcmQ9e2JvYXJkfVxuICAgICAgICBzZWxlY3RlZFNxdWFyZT17c2VsZWN0ZWRTcXVhcmV9XG4gICAgICAgIGxlZ2FsTW92ZXM9e2xlZ2FsTW92ZXN9XG4gICAgICAgIG9uU3F1YXJlQ2xpY2s9e2hhbmRsZVNlbGVjdFNxdWFyZX1cbiAgICAgIC8+XG4gICAgPC9zZWN0aW9uPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsInVzZVJlZiIsInVzZVN0YXRlIiwiQ2hlc3NCb2FyZCIsImNyZWF0ZUdhbWUiLCJnZXRMZWdhbE1vdmVzIiwibWFrZU1vdmUiLCJ1bmRvTW92ZSIsImNvbG9yTmFtZSIsImNvbG9yIiwib3Bwb3NpdGVDb2xvciIsImdldFN0YXR1cyIsImdhbWUiLCJpc0NoZWNrbWF0ZSIsInR1cm4iLCJpc1N0YWxlbWF0ZSIsImlzRHJhdyIsImNoZWNrU3VmZml4IiwiaW5DaGVjayIsIkNoZXNzR2FtZSIsImdhbWVSZWYiLCJib2FyZCIsInNldEJvYXJkIiwiY3VycmVudCIsInNlbGVjdGVkU3F1YXJlIiwic2V0U2VsZWN0ZWRTcXVhcmUiLCJsZWdhbE1vdmVzIiwic2V0TGVnYWxNb3ZlcyIsInN0YXR1cyIsInNldFN0YXR1cyIsInJlZnJlc2giLCJoYW5kbGVTZWxlY3RTcXVhcmUiLCJzcXVhcmUiLCJ0YXJnZXRNb3ZlIiwiZmluZCIsIm1vdmUiLCJ0byIsIm1vdmVSZXN1bHQiLCJwcm9tb3Rpb24iLCJwaWVjZSIsImdldCIsImhhbmRsZU5ld0dhbWUiLCJoYW5kbGVVbmRvIiwiY2FuVW5kbyIsImhpc3RvcnkiLCJsZW5ndGgiLCJzZWN0aW9uIiwiY2xhc3NOYW1lIiwiZGl2Iiwic3BhbiIsImJ1dHRvbiIsInR5cGUiLCJvbkNsaWNrIiwiZGlzYWJsZWQiLCJvblNxdWFyZUNsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ChessGame.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/chess.ts":
/*!**************************!*\
  !*** ./src/lib/chess.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGame: function() { return /* binding */ createGame; },\n/* harmony export */   getLegalMoves: function() { return /* binding */ getLegalMoves; },\n/* harmony export */   makeMove: function() { return /* binding */ makeMove; },\n/* harmony export */   undoMove: function() { return /* binding */ undoMove; }\n/* harmony export */ });\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chess.js */ \"(app-pages-browser)/./node_modules/.pnpm/chess.js@1.4.0/node_modules/chess.js/dist/esm/chess.js\");\n\nfunction createGame() {\n    return new chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess();\n}\nfunction getLegalMoves(game, square) {\n    return game.moves({\n        square,\n        verbose: true\n    });\n}\nfunction makeMove(game, from, to, promotion) {\n    var _game_move;\n    return (_game_move = game.move({\n        from,\n        to,\n        promotion: promotion !== null && promotion !== void 0 ? promotion : \"q\"\n    })) !== null && _game_move !== void 0 ? _game_move : null;\n}\nfunction undoMove(game) {\n    return game.undo();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY2hlc3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0M7QUFPeEMsU0FBU0M7SUFDZCxPQUFPLElBQUlELDJDQUFLQTtBQUNsQjtBQUVPLFNBQVNFLGNBQWNDLElBQVcsRUFBRUMsTUFBYztJQUN2RCxPQUFPRCxLQUFLRSxLQUFLLENBQUM7UUFBRUQ7UUFBUUUsU0FBUztJQUFLO0FBQzVDO0FBRU8sU0FBU0MsU0FBU0osSUFBVyxFQUFFSyxJQUFZLEVBQUVDLEVBQVUsRUFBRUMsU0FBNkI7UUFDcEZQO0lBQVAsT0FBT0EsQ0FBQUEsYUFBQUEsS0FBS1EsSUFBSSxDQUFDO1FBQUVIO1FBQU1DO1FBQUlDLFdBQVdBLHNCQUFBQSx1QkFBQUEsWUFBYTtJQUFJLGdCQUFsRFAsd0JBQUFBLGFBQXdEO0FBQ2pFO0FBRU8sU0FBU1MsU0FBU1QsSUFBVztJQUNsQyxPQUFPQSxLQUFLVSxJQUFJO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvY2hlc3MudHM/NDk1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGVzcywgTW92ZSwgU3F1YXJlIH0gZnJvbSBcImNoZXNzLmpzXCI7XG5cbmV4cG9ydCB0eXBlIHsgQ29sb3IsIE1vdmUsIFBpZWNlU3ltYm9sLCBTcXVhcmUgfSBmcm9tIFwiY2hlc3MuanNcIjtcblxuZXhwb3J0IHR5cGUgQ2hlc3NJbnN0YW5jZSA9IENoZXNzO1xuZXhwb3J0IHR5cGUgQm9hcmRTdGF0ZSA9IFJldHVyblR5cGU8Q2hlc3NbXCJib2FyZFwiXT47XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHYW1lKCk6IENoZXNzIHtcbiAgcmV0dXJuIG5ldyBDaGVzcygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVnYWxNb3ZlcyhnYW1lOiBDaGVzcywgc3F1YXJlOiBTcXVhcmUpOiBNb3ZlW10ge1xuICByZXR1cm4gZ2FtZS5tb3Zlcyh7IHNxdWFyZSwgdmVyYm9zZTogdHJ1ZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VNb3ZlKGdhbWU6IENoZXNzLCBmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUsIHByb21vdGlvbj86IE1vdmVbXCJwcm9tb3Rpb25cIl0pOiBNb3ZlIHwgbnVsbCB7XG4gIHJldHVybiBnYW1lLm1vdmUoeyBmcm9tLCB0bywgcHJvbW90aW9uOiBwcm9tb3Rpb24gPz8gXCJxXCIgfSkgPz8gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuZG9Nb3ZlKGdhbWU6IENoZXNzKTogTW92ZSB8IG51bGwge1xuICByZXR1cm4gZ2FtZS51bmRvKCk7XG59XG4iXSwibmFtZXMiOlsiQ2hlc3MiLCJjcmVhdGVHYW1lIiwiZ2V0TGVnYWxNb3ZlcyIsImdhbWUiLCJzcXVhcmUiLCJtb3ZlcyIsInZlcmJvc2UiLCJtYWtlTW92ZSIsImZyb20iLCJ0byIsInByb21vdGlvbiIsIm1vdmUiLCJ1bmRvTW92ZSIsInVuZG8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/chess.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \********************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMzNfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsa0xBQTBCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjMzX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzP2MzMmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpOyAvLyBUT0RPOiBEZWxldGUgd2l0aCBlbmFibGVSZW5kZXJhYmxlQ29udGV4dFxuXG52YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnN1bWVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbnZhciBlbmFibGVSZW5kZXJhYmxlQ29udGV4dCA9IGZhbHNlO1xuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMiA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTsgLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyKSB7XG4gICAgICAvLyBUT0RPOiBDcmVhdGUgYSBjb252ZW50aW9uIGZvciBuYW1pbmcgY2xpZW50IHJlZmVyZW5jZXMgd2l0aCBkZWJ1ZyBpbmZvLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJ0NhY2hlJztcbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCBlbmFibGVSZW5kZXJhYmxlQ29udGV4dCAgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuLyoqXG4gKiBMZXZlcmFnZXMgbmF0aXZlIGJyb3dzZXIvVk0gc3RhY2sgZnJhbWVzIHRvIGdldCBwcm9wZXIgZGV0YWlscyAoZS5nLlxuICogZmlsZW5hbWUsIGxpbmUgKyBjb2wgbnVtYmVyKSBmb3IgYSBzaW5nbGUgY29tcG9uZW50IGluIGEgY29tcG9uZW50IHN0YWNrLiBXZVxuICogZG8gdGhpcyBieTpcbiAqICAgKDEpIHRocm93aW5nIGFuZCBjYXRjaGluZyBhbiBlcnJvciBpbiB0aGUgZnVuY3Rpb24gLSB0aGlzIHdpbGwgYmUgb3VyXG4gKiAgICAgICBjb250cm9sIGVycm9yLlxuICogICAoMikgY2FsbGluZyB0aGUgY29tcG9uZW50IHdoaWNoIHdpbGwgZXZlbnR1YWxseSB0aHJvdyBhbiBlcnJvciB0aGF0IHdlJ2xsXG4gKiAgICAgICBjYXRjaCAtIHRoaXMgd2lsbCBiZSBvdXIgc2FtcGxlIGVycm9yLlxuICogICAoMykgZGlmZmluZyB0aGUgY29udHJvbCBhbmQgc2FtcGxlIGVycm9yIHN0YWNrcyB0byBmaW5kIHRoZSBzdGFjayBmcmFtZVxuICogICAgICAgd2hpY2ggcmVwcmVzZW50cyBvdXIgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuICAvKipcbiAgICogRmluZGluZyBhIGNvbW1vbiBzdGFjayBmcmFtZSBiZXR3ZWVuIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgY2FuIGJlXG4gICAqIHRyaWNreSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzIGFuZCBsZXZlbHMgb2Ygc3RhY2sgdHJhY2UgdHJ1bmNhdGlvbiBmcm9tXG4gICAqIGRpZmZlcmVudCBKUyBWTXMuIFNvIGluc3RlYWQgd2UnbGwgYXR0ZW1wdCB0byBjb250cm9sIHdoYXQgdGhhdCBjb21tb25cbiAgICogZnJhbWUgc2hvdWxkIGJlIHRocm91Z2ggdGhpcyBvYmplY3QgbWV0aG9kOlxuICAgKiBIYXZpbmcgYm90aCB0aGUgc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBiZSBpbiB0aGUgZnVuY3Rpb24gdW5kZXIgdGhlXG4gICAqIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgcHJvcGVydHksICsgc2V0dGluZyB0aGUgYG5hbWVgIGFuZFxuICAgKiBgZGlzcGxheU5hbWVgIHByb3BlcnRpZXMgb2YgdGhlIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBhIHN0YWNrXG4gICAqIGZyYW1lIGV4aXN0cyB0aGF0IGhhcyB0aGUgbWV0aG9kIG5hbWUgYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBpblxuICAgKiBpdCBmb3IgYm90aCBjb250cm9sIGFuZCBzYW1wbGUgc3RhY2tzLlxuICAgKi9cblxuXG4gIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250cm9sO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICB9IC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSBmbigpOyAvLyBJZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHJldHVybnMgYSBwcm9taXNlLCBpdCdzIGxpa2VseSBhbiBhc3luY1xuICAgICAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgICAgIC8vIHNpbGVuY2UgdGhlIGVycm9yLlxuICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBjb21wb25lbnQgc3RhY2tzIGZvciBhc3luYyBjbGllbnQgY29tcG9uZW50cz9cblxuICAgICAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICB9XG4gIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnO1xuICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsICduYW1lJyk7IC8vIEJlZm9yZSBFUzYsIHRoZSBgbmFtZWAgcHJvcGVydHkgd2FzIG5vdCBjb25maWd1cmFibGUuXG5cbiAgaWYgKG5hbWVQcm9wRGVzY3JpcHRvciAmJiBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgLy8gVjggdXRpbGl6ZXMgYSBmdW5jdGlvbidzIGBuYW1lYCBwcm9wZXJ0eSB3aGVuIGdlbmVyYXRpbmcgYSBzdGFjayB0cmFjZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAvLyBDb25maWd1cmFibGUgcHJvcGVydGllcyBjYW4gYmUgdXBkYXRlZCBldmVuIGlmIGl0cyB3cml0YWJsZSBkZXNjcmlwdG9yXG4gICAgLy8gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG4gICAgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCdcbiAgICB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuXG4gICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IDA7XG4gICAgICB2YXIgYyA9IDA7XG5cbiAgICAgIHdoaWxlIChzIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmICFzYW1wbGVMaW5lc1tzXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgcysrO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoYyA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiYgIWNvbnRyb2xMaW5lc1tjXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgYysrO1xuICAgICAgfSAvLyBXZSBjb3VsZG4ndCBmaW5kIG91ciBpbnRlbnRpb25hbGx5IGluamVjdGVkIGNvbW1vbiByb290IGZyYW1lLCBhdHRlbXB0XG4gICAgICAvLyB0byBmaW5kIGFub3RoZXIgY29tbW9uIHJvb3QgZnJhbWUgYnkgc2VhcmNoIGZyb20gdGhlIGJvdHRvbSBvZiB0aGVcbiAgICAgIC8vIGNvbnRyb2wgc3RhY2suLi5cblxuXG4gICAgICBpZiAocyA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8IGMgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICAgIGMtLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHtcbiAgICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG5mdW5jdGlvbiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCBfcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgcmVmO1xuXG4gIHtcbiAgICByZWYgPSBfcmVmO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQ7XG5cbiAge1xuICAgIC8vIEluIHByb2QsIGByZWZgIGlzIGEgcmVndWxhciBwcm9wZXJ0eS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIGFcbiAgICAvLyBmdXR1cmUgcmVsZWFzZS5cbiAgICBlbGVtZW50ID0ge1xuICAgICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGtleToga2V5LFxuICAgICAgcmVmOiByZWYsXG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgX293bmVyOiBvd25lclxuICAgIH07XG4gIH1cblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIGRlYnVnSW5mbyBjb250YWlucyBTZXJ2ZXIgQ29tcG9uZW50IGRlYnVnIGluZm9ybWF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfZGVidWdJbmZvJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFViQxKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gaW52YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvL1xuICAgICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhIHZhbGlkIGVsZW1lbnQgdHlwZS5cbiAgICAgIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZ1xuICAgICAgLy8gZXJyb3JzLiBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kXG4gICAgICAvLyBwcm9kLiAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGVcbiAgICAgIC8vIHR5cGUgaXMgZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBXYXJuIGFib3V0IGtleSBzcHJlYWQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSB0eXBlIGlzIHZhbGlkLlxuXG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB9XG5cbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgLy8gU2tpcCBvdmVyIHJlc2VydmVkIHByb3AgbmFtZXNcbiAgICAgIHByb3BOYW1lICE9PSAna2V5JyAmJiAocHJvcE5hbWUgIT09ICdyZWYnKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkgOyBlbHNlIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byByZW5kZXIgcGhhc2UgaW5zdGVhZCBvZiBhdCBlbGVtZW50IGNyZWF0aW9uLlxuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBqc3hERVYgPSBqc3hERVYkMSA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVY7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \**********************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMzNfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsMFFBQXNFO0FBQ3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMzNfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9mYzdjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js ***!
  \******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (arg) {\n\t\t\t\tclasses = appendClass(classes, parseValue(arg));\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction parseValue (arg) {\n\t\tif (typeof arg === 'string' || typeof arg === 'number') {\n\t\t\treturn arg;\n\t\t}\n\n\t\tif (typeof arg !== 'object') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (Array.isArray(arg)) {\n\t\t\treturn classNames.apply(null, arg);\n\t\t}\n\n\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\treturn arg.toString();\n\t\t}\n\n\t\tvar classes = '';\n\n\t\tfor (var key in arg) {\n\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\tclasses = appendClass(classes, key);\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction appendClass (value, newClass) {\n\t\tif (!newClass) {\n\t\t\treturn value;\n\t\t}\n\t\n\t\tif (value) {\n\t\t\treturn value + ' ' + newClass;\n\t\t}\n\t\n\t\treturn value + newClass;\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9jbGFzc25hbWVzQDIuNS4xL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLEtBQTZCO0FBQ2xDO0FBQ0E7QUFDQSxHQUFHLFNBQVMsSUFBNEU7QUFDeEY7QUFDQSxFQUFFLGlDQUFxQixFQUFFLG1DQUFFO0FBQzNCO0FBQ0EsR0FBRztBQUFBLGtHQUFDO0FBQ0osR0FBRyxLQUFLLEVBRU47QUFDRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9jbGFzc25hbWVzQDIuNS4xL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzPzg1ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG5cdENvcHlyaWdodCAoYykgMjAxOCBKZWQgV2F0c29uLlxuXHRMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuXHRodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gJyc7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmIChhcmcpIHtcblx0XHRcdFx0Y2xhc3NlcyA9IGFwcGVuZENsYXNzKGNsYXNzZXMsIHBhcnNlVmFsdWUoYXJnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZVZhbHVlIChhcmcpIHtcblx0XHRpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcblx0XHRcdHJldHVybiBhcmc7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBhcmcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHR9XG5cblx0XHRpZiAoYXJnLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICYmICFhcmcudG9TdHJpbmcudG9TdHJpbmcoKS5pbmNsdWRlcygnW25hdGl2ZSBjb2RlXScpKSB7XG5cdFx0XHRyZXR1cm4gYXJnLnRvU3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGNsYXNzZXMgPSAnJztcblxuXHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0Y2xhc3NlcyA9IGFwcGVuZENsYXNzKGNsYXNzZXMsIGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBlbmRDbGFzcyAodmFsdWUsIG5ld0NsYXNzKSB7XG5cdFx0aWYgKCFuZXdDbGFzcykge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgKyAnICcgKyBuZXdDbGFzcztcblx0XHR9XG5cdFxuXHRcdHJldHVybiB2YWx1ZSArIG5ld0NsYXNzO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/.pnpm/next@14.2.33_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fworkspaces%2Fchess-codex%2Fsrc%2Fcomponents%2FChessGame.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);